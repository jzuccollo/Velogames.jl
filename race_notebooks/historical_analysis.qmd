---
title: "Historical analysis"
subtitle: "Retrospective optimal team selection from actual race results"
format: html
---

# Configuration

Set the race details and competition benchmark to analyse:

```{julia}
using Velogames, DataFrames, MarkdownTables, Printf, Statistics

# Race configuration
race_name = "liege"  # Short name from get_url_pattern (e.g. "omloop", "tdf", "vuelta")
race_year = 2024
racehash = "#LiegeBastogneLiege"  # VG startlist hash filter (leave empty for all riders)

# Race results URL (the ridescore page for the specific race)
riderraceurl = "https://www.velogames.com/sixes-superclasico/2024/ridescore.php?ga=13&st=21"

# Competition benchmark (optional: set to compare against a league winner)
winner_name = "James"
winner_score = 1074

# Cache configuration
analysis_cache = CacheConfig(joinpath(homedir(), ".velogames_cache"), 168, true)
```

# Race setup

```{julia}
#| echo: false
config = setup_race(race_name, race_year; cache_config=analysis_cache)
print_race_info(config)

is_stage = config.type == :stage
println("Analysis type: $(is_stage ? "Stage race" : "One-day race")")
if !isempty(winner_name)
    println("Benchmark: $winner_name scored $winner_score points")
end
```

# Data loading

```{julia}
#| echo: false
# Fetch rider costs and actual race results
ridervg = getvgriders(config.current_url; cache_config=analysis_cache)
riderrace = getvgracepoints(riderraceurl; cache_config=analysis_cache)

# Filter to startlist if hash provided
if !isempty(racehash)
    filtered = filter(row -> row.startlist == racehash, ridervg)
    if nrow(filtered) > 0
        ridervg = filtered
        println("Filtered to $(nrow(ridervg)) riders for startlist: $racehash")
    else
        println("No riders found for hash $racehash, using all $(nrow(ridervg)) riders")
    end
end

# Join race results with rider costs
allriders = leftjoin(riderrace, ridervg, on=:riderkey, makeunique=true)
allriders = coalesce.(allriders, 0)

# Clean team names for display
if hasproperty(allriders, :team)
    allriders[!, :team] = replace.(allriders[!, :team], r"\|" => "-")
end

println("Loaded $(nrow(allriders)) riders with race results")
scoring_riders = count(allriders.score .> 0)
println("Scoring riders: $scoring_riders")
```

# Optimal team

The best team you could have picked, with hindsight:

```{julia}
#| echo: false
# Build the appropriate optimisation model based on race type
if is_stage
    results = build_model_stage(allriders, config.team_size, :score, :cost; totalcost=100)
else
    results = build_model_oneday(allriders, config.team_size, :score, :cost; totalcost=100)
end

if results !== nothing
    chosen_vec = [results[r] for r in allriders.riderkey]
    allriders[!, :chosen] = chosen_vec .> 0.5
    optimal_team = filter(:chosen => ==(true), allriders)

    optimal_score = sum(optimal_team.score)
    optimal_cost = sum(optimal_team.cost)

    println("OPTIMAL TEAM")
    println("="^40)
    println("Total score: $optimal_score points")
    println("Total cost: $optimal_cost / 100 credits")
    println("Team size: $(nrow(optimal_team)) riders")

    if !isempty(winner_name) && winner_score > 0
        improvement = optimal_score - winner_score
        println("vs $winner_name: $(improvement > 0 ? "+" : "")$improvement points")
    end
    println()

    # Display columns depend on race type
    display_cols = [:rider, :team, :cost, :score]
    if is_stage && hasproperty(optimal_team, :classraw)
        insert!(display_cols, 3, :classraw)
    end

    team_display = sort(optimal_team[:, display_cols], :score, rev=true)
    display(markdown_table(team_display))
else
    println("Optimisation failed - no feasible solution found")
end
```

```{julia}
#| echo: false
# Classification breakdown for stage races
if is_stage && @isdefined(optimal_team) && hasproperty(optimal_team, :classraw)
    println("\nClassification breakdown:")
    for class in sort(unique(optimal_team.classraw))
        n = count(optimal_team.classraw .== class)
        pts = sum(optimal_team[optimal_team.classraw .== class, :score])
        println("  $class: $n riders, $pts points")
    end
end
```

# Cheapest winning team

The minimum cost team that would have beaten the benchmark:

```{julia}
#| echo: false
if !isempty(winner_name) && winner_score > 0
    if is_stage
        # Use minimise_cost_stage for stage races (has classification constraints)
        cheap_results = minimise_cost_stage(allriders, winner_score, config.team_size, :score, :cost; totalcost=100)
    else
        # For one-day races, build a custom min-cost model
        using HiGHS, JuMP
        cheap_model = JuMP.Model(HiGHS.Optimizer)
        JuMP.set_silent(cheap_model)
        JuMP.@variable(cheap_model, x[allriders.rider], Bin)
        JuMP.@objective(cheap_model, Min, allriders.cost' * x)
        JuMP.@constraint(cheap_model, allriders.score' * x >= winner_score + 1)
        JuMP.@constraint(cheap_model, sum(x) == config.team_size)
        JuMP.optimize!(cheap_model)

        if JuMP.termination_status(cheap_model) == MOI.OPTIMAL
            cheap_results = JuMP.value.(x)
        else
            cheap_results = nothing
        end
    end

    if cheap_results !== nothing
        cheap_chosen = [cheap_results[r] for r in allriders.riderkey] .> 0.5
        cheapest_team = allriders[cheap_chosen, :]

        cheapest_score = sum(cheapest_team.score)
        cheapest_cost = sum(cheapest_team.cost)

        println("CHEAPEST TEAM TO BEAT $winner_name ($winner_score pts)")
        println("="^50)
        println("Total score: $cheapest_score points")
        println("Total cost: $cheapest_cost / 100 credits")
        println("Budget saved: $(100 - cheapest_cost) credits")
        println()

        display_cols = [:rider, :team, :cost, :score]
        if is_stage && hasproperty(cheapest_team, :classraw)
            insert!(display_cols, 3, :classraw)
        end

        cheap_display = sort(cheapest_team[:, display_cols], :score, rev=true)
        display(markdown_table(cheap_display))
    else
        println("No feasible team found that beats $winner_name's $winner_score points")
    end
else
    println("No benchmark set - skip this section by leaving winner_name and winner_score empty")
end
```

# Rider value analysis

Points scored per credit of cost, showing which riders delivered the best value:

```{julia}
#| echo: false
scorers = filter(row -> row.score > 0, allriders)

if nrow(scorers) > 0
    scorers[!, :value] = round.(scorers.score ./ scorers.cost, digits=1)
    sort!(scorers, :value, rev=true)

    # Top 20 value riders
    top_n = min(20, nrow(scorers))
    println("TOP $top_n VALUE RIDERS")
    println("="^40)

    display_cols = [:rider, :team, :cost, :score, :value]
    if is_stage && hasproperty(scorers, :classraw)
        insert!(display_cols, 3, :classraw)
    end

    display(markdown_table(scorers[1:top_n, display_cols]))

    # Summary statistics
    println()
    println("Value summary:")
    println("  Best: $(maximum(scorers.value)) pts/credit")
    println("  Average: $(round(mean(scorers.value), digits=1)) pts/credit")
    println("  Scoring riders: $(nrow(scorers)) / $(nrow(allriders))")
else
    println("No riders scored points in this race")
end
```

```{julia}
#| echo: false
# Stage race class value analysis
if is_stage && nrow(scorers) > 0 && hasproperty(scorers, :classraw)
    println("\nVALUE BY CLASSIFICATION")
    println("="^40)
    for class in sort(unique(scorers.classraw))
        class_riders = filter(row -> row.classraw == class, scorers)
        avg_val = round(mean(class_riders.value), digits=1)
        avg_pts = round(mean(class_riders.score), digits=0)
        println("  $class: $(nrow(class_riders)) riders, avg $(avg_pts) pts, avg value $(avg_val)")
    end
end
```

# How to use this notebook

**Quick start:**

1. Update `race_name` and `race_year` for the race you want to analyse
2. Set `riderraceurl` to the VG results page URL for that race
3. Set `racehash` if the race uses startlist filtering
4. Optionally set `winner_name` and `winner_score` to compare against a league benchmark
5. Run all cells

The notebook auto-detects whether the race is one-day or stage from `RaceConfig` and uses the appropriate optimisation model:

- **One-day races**: `build_model_oneday` with 6 riders, no classification constraints
- **Stage races**: `build_model_stage` with 9 riders and classification constraints (2 all-rounders, 2 climbers, 1 sprinter, 3+ unclassed)

Both use deterministic optimisation on actual race results rather than Monte Carlo prediction. For pre-race predictions, use `oneday_predictor.qmd` or `stagerace_predictor.qmd` instead.
