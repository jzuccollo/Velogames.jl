---
title: "Superclassico Sixes Team Builder"
subtitle: "Monte Carlo simulation-based fantasy cycling team optimizer"
format: html
---

# Configuration

Set up the race details and optimization parameters:

```{julia}
using Velogames, DataFrames, Statistics, MarkdownTables

# Race Configuration
race_name = "omloop"  # Short name from get_url_pattern (e.g. "omloop", "kuurne", "roubaix", "flanders")
race_year = 2025
racehash = ""  # VG startlist hash filter (leave empty for all riders)

# Optional: Betfair odds URL (leave empty to skip)
odds_url = ""

# Simulation Parameters
n_sims = 10000  # Monte Carlo simulations (more = smoother, slower)
history_years = 5  # How many years of race history to use

# Exclusions (add rider names to avoid)
excluded_riders = String[]

# Cache Configuration
race_cache = CacheConfig(joinpath(homedir(), ".velogames_cache"), 6, true)
```

# Race Setup

```{julia}
#| echo: false
# Set up race configuration from the short name
config = setup_race(race_name, race_year; cache_config=race_cache)

print_race_info(config)
scoring = get_scoring(config.category > 0 ? config.category : 2)
println("Scoring: Category $(config.category)")
println("PCS slug: $(config.pcs_slug)")
println("Simulations: $n_sims")
```

# Team Optimization

```{julia}
#| echo: false
println("BUILDING OPTIMAL TEAM")
println("="^40)

# Run the full prediction pipeline
predicted, chosenteam = solverace_sixes(config;
    racehash=racehash,
    history_years=history_years,
    odds_url=odds_url,
    n_sims=n_sims,
    excluded_riders=excluded_riders,
    cache_config=race_cache)

println()
println("Pipeline complete: $(nrow(predicted)) riders analysed")
```

# Your Optimal Team

```{julia}
#| echo: false
if @isdefined(chosenteam) && nrow(chosenteam) > 0
    cost_col = :vgcost in propertynames(chosenteam) ? :vgcost : :cost
    total_cost = sum(chosenteam[!, cost_col])
    total_evg = sum(chosenteam.expected_vg_points)

    println("YOUR OPTIMAL TEAM")
    println("="^40)
    println("Total Cost: $total_cost / 100 credits")
    println("Expected VG Points: $(round(total_evg, digits=1))")
    println("Budget Remaining: $(100 - total_cost) credits")
    println("Team Size: $(nrow(chosenteam)) riders")
    println()

    # Display team with key columns
    display_cols = [:rider, :team, cost_col, :expected_vg_points, :strength, :uncertainty]
    # Add component breakdown if available
    for col in [:expected_finish_pts, :expected_assist_pts, :expected_breakaway_pts]
        if col in propertynames(chosenteam)
            push!(display_cols, col)
        end
    end

    team_display = chosenteam[:, display_cols]

    # Round numeric columns for display
    for col in names(team_display)
        if eltype(team_display[!, col]) <: Union{Missing, Number}
            team_display[!, col] = round.(team_display[!, col], digits=1)
        end
    end

    # Clean team names
    if hasproperty(team_display, :team)
        team_display = transform(team_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
    end

    display(markdown_table(sort(team_display, :expected_vg_points, rev=true)))
else
    println("No optimal team generated - check configuration and try again")
end
```

# Full Prediction Rankings

Top 30 riders by expected VG points:

```{julia}
#| echo: false
if @isdefined(predicted) && nrow(predicted) > 0
    cost_col = :vgcost in propertynames(predicted) ? :vgcost : :cost

    # Show top 30 riders
    ranking_cols = [:rider, :team, cost_col, :expected_vg_points, :strength, :uncertainty]
    for col in [:expected_finish_pts, :expected_assist_pts, :expected_breakaway_pts]
        if col in propertynames(predicted)
            push!(ranking_cols, col)
        end
    end

    # Add chosen indicator
    if :chosen in propertynames(predicted)
        push!(ranking_cols, :chosen)
    end

    ranking = sort(predicted[:, ranking_cols], :expected_vg_points, rev=true)
    top_n = min(30, nrow(ranking))
    ranking_display = ranking[1:top_n, :]

    # Round for display
    for col in names(ranking_display)
        if eltype(ranking_display[!, col]) <: Union{Missing, Number}
            ranking_display[!, col] = round.(ranking_display[!, col], digits=1)
        end
    end

    if hasproperty(ranking_display, :team)
        ranking_display = transform(ranking_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
    end

    display(markdown_table(ranking_display))
end
```

# Alternative Picks

```{julia}
#| echo: false
if @isdefined(predicted) && @isdefined(chosenteam) && nrow(chosenteam) > 0
    cost_col = :vgcost in propertynames(predicted) ? :vgcost : :cost

    println("ALTERNATIVE CONSIDERATIONS")
    println("="^45)

    # Get riders not in optimal team
    not_chosen = filter(:chosen => ==(false), predicted)

    if nrow(not_chosen) > 0
        not_chosen[!, :value] = not_chosen.expected_vg_points ./ not_chosen[!, cost_col]

        # Top 10 value picks not selected
        println("\nTop Value Riders Not Selected:")
        top_value = sort(not_chosen, :value, rev=true)[1:min(10, nrow(not_chosen)), :]
        value_display = top_value[:, [:rider, :team, cost_col, :expected_vg_points, :value]]
        for col in names(value_display)
            if eltype(value_display[!, col]) <: Union{Missing, Number}
                value_display[!, col] = round.(value_display[!, col], digits=1)
            end
        end
        if hasproperty(value_display, :team)
            value_display = transform(value_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
        end
        display(markdown_table(value_display))

        # High-upside picks (high strength, high uncertainty)
        println("\nHigh Upside Picks (strong but uncertain):")
        not_chosen[!, :upside] = not_chosen.strength .+ not_chosen.uncertainty
        upside = sort(not_chosen, :upside, rev=true)[1:min(5, nrow(not_chosen)), :]
        upside_display = upside[:, [:rider, :team, cost_col, :expected_vg_points, :strength, :uncertainty]]
        for col in names(upside_display)
            if eltype(upside_display[!, col]) <: Union{Missing, Number}
                upside_display[!, col] = round.(upside_display[!, col], digits=1)
            end
        end
        if hasproperty(upside_display, :team)
            upside_display = transform(upside_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
        end
        display(markdown_table(upside_display))

        # Budget options
        println("\nBudget Options (cost <= 6):")
        cheap_options = filter(row -> row[cost_col] <= 6, not_chosen)
        if nrow(cheap_options) > 0
            cheap_sorted = sort(cheap_options, :expected_vg_points, rev=true)[1:min(5, nrow(cheap_options)), :]
            cheap_display = cheap_sorted[:, [:rider, :team, cost_col, :expected_vg_points]]
            for col in names(cheap_display)
                if eltype(cheap_display[!, col]) <: Union{Missing, Number}
                    cheap_display[!, col] = round.(cheap_display[!, col], digits=1)
                end
            end
            if hasproperty(cheap_display, :team)
                cheap_display = transform(cheap_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
            end
            display(markdown_table(cheap_display))
        else
            println("No riders at cost <= 6 available")
        end
    else
        println("All available riders were selected!")
    end
end
```

# How to Use This Tool

**Quick Start:**

1. Update `race_name` to the short name of the race (e.g. `"omloop"`, `"kuurne"`, `"roubaix"`, `"flanders"`)
2. Update `race_year` to the current year
3. Optionally set `racehash` if the VG site uses startlist filtering
4. Run all cells to get your optimal team
5. Copy the team into VeloGames

**Available Race Names:**
Use `get_url_pattern("name")` to check. Examples: `omloop`, `kuurne`, `strade`, `sanremo`, `roubaix`, `flanders`, `agr`, `fleche`, `ljl`, `eschborn`, `worlds`.

**Prediction Pipeline:**
The optimizer now uses Monte Carlo simulation to estimate **expected Velogames points** for each rider:

1. Fetches VG rider costs and season points
2. Fetches PCS specialty ratings (one-day, GC, sprint, climb, TT)
3. Fetches PCS race-specific history (past editions of this race)
4. Optionally fetches betting odds from Betfair
5. Estimates rider strength via Bayesian updating of all signals
6. Runs Monte Carlo simulation to get finishing position probabilities
7. Computes expected VG points (finish + assists + breakaway)
8. Optimizes team selection to maximize total expected VG points

**Customization:**

- Set `odds_url` to a Betfair market URL for odds integration (strongest single signal when available)
- Adjust `n_sims` for speed vs accuracy (10000 is a good default)
- Adjust `history_years` for how much race history to consider
- Add rider names to `excluded_riders` to avoid specific riders
- Review "Alternative Picks" for high-upside or value swaps
