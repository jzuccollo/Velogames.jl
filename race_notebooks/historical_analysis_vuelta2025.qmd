---
title: "Vuelta a España 2025: A Fantasy Retrospective"
subtitle: "A fantasy retrospective on the key performers and the perfect team"
format:
  html:
    code-fold: false
    toc: true
---

The Vuelta a España 2025 has concluded. This analysis examines the fantasy competition results, identifying the highest-performing riders and the optimal team composition using complete race data.

```{julia}
#| echo: false
#| output: false
#| cache: true

using Velogames, DataFrames, MarkdownTables, Plots, Printf, JuMP, HiGHS, StatsPlots, Statistics, Random

plotly() # Use Plotly backend for interactive plots

# Race configuration - Vuelta a España 2025 Final analysis
ridersurl = "https://www.velogames.com/spain/2025/riders.php"
league_winner = "Salsa Tequila"
winning_score = 10965

# Create Vuelta final analysis cache
vuelta_final_cache = CacheConfig("/tmp/vuelta_final_2025", 6, true)

# Data loading and initial processing
allriderdata = getvgriders(ridersurl; cache_config=vuelta_final_cache)
rider_names = collect(allriderdata.rider)
pcs_df = getpcsriderpts_batch(rider_names; cache_config=vuelta_final_cache)
vg_class_to_pcs_col = Dict(
    "allrounder" => "gc",
    "climber" => "climber",
    "sprinter" => "sprint",
    "unclassed" => "oneday"
)
add_pcs_speciality_points!(allriderdata, pcs_df, vg_class_to_pcs_col)

# Set up the optimization model for the best possible team using final results
println("Starting optimization with $(nrow(allriderdata)) riders")
println("Total points available: $(sum(allriderdata.points))")
println("Riders with points > 0: $(sum(allriderdata.points .> 0))")
println("Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")

# Check data quality before optimization
if any(ismissing.(allriderdata.points)) || any(ismissing.(allriderdata.cost))
    println("⚠️ Warning: Missing values detected in points or cost columns")
end

# Let's also try to understand the optimization problem better
println("\nDebug: Examining class structure...")
println("Unique classes in data: $(unique(allriderdata.class))")

# Fix class name mismatch - the optimization function expects title case
class_mapping = Dict(
    "allrounder" => "All rounder",
    "climber" => "Climber",
    "sprinter" => "Sprinter",
    "unclassed" => "Unclassed"
)

println("Fixing class names for optimization...")
allriderdata.class = [get(class_mapping, class, class) for class in allriderdata.class]
println("Updated classes: $(unique(allriderdata.class))")

solution = buildmodelhistorical(allriderdata, 9, :points, :cost; totalcost=100)
if solution !== nothing
    chosen_values = [solution[rider] > 0.5 for rider in allriderdata.rider]
    allriderdata.chosen = chosen_values
    chosenteam = filter(row -> row.chosen, allriderdata)
    println("✅ Optimization successful: Found team with $(sum(chosenteam.points)) points, costing $(sum(chosenteam.cost)) credits")
else
    # More detailed diagnostic information if optimization fails
    println("❌ Optimization failed.")
    println("\nDetailed diagnostic information:")
    println("Data summary:")
    println("- Total riders: $(nrow(allriderdata))")
    println("- Points range: $(minimum(allriderdata.points)) - $(maximum(allriderdata.points))")
    println("- Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")
    println("- Unique classes: $(unique(allriderdata.class))")

    # Check if we have riders in each required class (use actual class names from data)
    class_counts = combine(groupby(allriderdata, :class), nrow => :count)
    println("\nClass distribution:")
    for row in eachrow(class_counts)
        println("  - $(row.class): $(row.count) riders")
    end

    # The issue might be that the class names don't match what the function expects
    # Let's manually check what classes we actually have
    expected_classes = ["All rounder", "Climber", "Sprinter", "Unclassed"]
    actual_classes = unique(allriderdata.class)
    println("\nClass name matching:")
    println("Expected classes: $(expected_classes)")
    println("Actual classes: $(actual_classes)")

    missing_classes = setdiff(expected_classes, actual_classes)
    if !isempty(missing_classes)
        println("❌ Missing expected classes: $(missing_classes)")
        println("This is likely why optimization failed!")
    end

    # Proceed with fallback analysis without optimization
    println("\nProceeding with analysis using top performers instead of optimal team...")
    chosenteam = sort(allriderdata, :points, rev=true)[1:9, :]
    allriderdata.chosen = [rider in chosenteam.rider for rider in allriderdata.rider]
    println("Fallback team total points: $(sum(chosenteam.points))")
end

# Calculate current value and identify standout performers

# Let's also check constraint feasibility for debugging
println("Constraint feasibility check:")
println("Can we form a valid team?")

# Check if we can satisfy class constraints with budget - using corrected class names
allrounder_riders = filter(row -> row.class == "All rounder", allriderdata)
climber_riders = filter(row -> row.class == "Climber", allriderdata)
sprinter_riders = filter(row -> row.class == "Sprinter", allriderdata)
unclassed_riders = filter(row -> row.class == "Unclassed", allriderdata)

println("Available riders by class:")
println("- All rounders: $(nrow(allrounder_riders))")
if nrow(allrounder_riders) >= 2
    println("  Cheapest 2: $(sort(allrounder_riders.cost)[1:2])")
end
println("- Climbers: $(nrow(climber_riders))")
if nrow(climber_riders) >= 2
    println("  Cheapest 2: $(sort(climber_riders.cost)[1:2])")
end
println("- Sprinters: $(nrow(sprinter_riders))")
if nrow(sprinter_riders) >= 1
    println("  Cheapest: $(minimum(sprinter_riders.cost))")
end
println("- Unclassed: $(nrow(unclassed_riders))")
if nrow(unclassed_riders) >= 4
    println("  Cheapest 4: $(sort(unclassed_riders.cost)[1:4])")
end

# Check minimum cost for a valid team (2 AR, 2 C, 1 S, 4 U)
if nrow(allrounder_riders) >= 2 && nrow(climber_riders) >= 2 && nrow(sprinter_riders) >= 1 && nrow(unclassed_riders) >= 4
    min_cost = sum(sort(allrounder_riders.cost)[1:2]) + sum(sort(climber_riders.cost)[1:2]) + minimum(sprinter_riders.cost) + sum(sort(unclassed_riders.cost)[1:4])
    println("Minimum cost for a valid team: $(min_cost)")
else
    println("❌ Insufficient riders in one or more classes!")
end

# Find the cheapest team that would have won the league (if winning_score > 0)
if winning_score > 0
    costsolution = minimizecostforstage(allriderdata, winning_score, 9, :cost; totalcost=100)
    if costsolution !== nothing
        chosen2_values = [costsolution[rider] > 0.5 for rider in allriderdata.rider]
        allriderdata.chosen2 = chosen2_values
        chosen2team = filter(row -> row.chosen2, allriderdata)
    else
        println("Cost minimization failed")
        chosen2team = DataFrame()
    end
else
    chosen2team = DataFrame() # No cost minimization analysis without a target score
end

# Calculate value for each rider
allriderdata.value = allriderdata.points ./ allriderdata.cost

# Add some jitter to cost for better visualization
Random.seed!(42)
jitter_amount = 0.5
allriderdata.jittered_cost = allriderdata.cost .+ (rand(nrow(allriderdata)) .- 0.5) .* jitter_amount

# Create hover text for plots
allriderdata.hover_text = [
    "$(row.rider)\n$(row.team)\n$(row.class)\nCost: $(row.cost)\nPoints: $(round(row.points, digits=1))\nValue: $(round(row.value, digits=2))"
    for row in eachrow(allriderdata)
]
```

## League Performance Benchmark

The winning team in our league, **`{julia} league_winner`**, scored **`{julia} winning_score`** points. This is the benchmark for our retrospective analysis.

## Optimal Team Composition

Using complete race results, optimization analysis identifies the highest-scoring combination of nine riders within budget and classification constraints. The optimal team would have scored **`{julia} Int(round(sum(chosenteam.points)))`** points at a cost of **`{julia} Int(sum(chosenteam.cost))`** credits.

```{julia}
#| echo: false
#| output: asis

if winning_score > 0 && sum(chosenteam.points) > winning_score
    margin = Int(round(sum(chosenteam.points) - winning_score))
    println("This represents a $(margin)-point improvement over the league winner.")
elseif winning_score > 0
    margin = Int(round(sum(chosenteam.points) - winning_score))
    println("This would have been sufficient to win by $(margin) points.")
end
```

Here is the optimal team:

```{julia}
#| echo: false

# Create and display the optimal team table
displaytable = select(chosenteam, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :Score)
displaytable[!, :Score] = Int.(round.(displaytable.Score))
markdown_table(displaytable)
```

```{julia}
#| echo: false
#| output: asis

if !isempty(chosen2team) && winning_score > 0
    cost_points = Int(round(sum(chosen2team.points)))
    cost_credits = Int(sum(chosen2team.cost))

    println("## Minimum Winning Cost")
    println()
    println("Analysis of the lowest-cost team capable of defeating the league winner. This team would have scored $(cost_points) points at a cost of $(cost_credits) credits.")
    println()
    println("Minimum cost winning team:")
    println()

    displaytable2 = select(chosen2team, :rider => :Rider, :team => :Team,
        :class => :Class, :cost => :Cost, :points => :Score)
    displaytable2[!, :Score] = Int.(round.(displaytable2.Score))
    markdown_table(displaytable2)
end
```

# Rider Value Analysis

This chart plots rider cost against points scored, showing the relationship between price and performance.

```{julia}
#| echo: false
#| fig-cap: "Plot of final race points versus rider cost, coloured by rider classification."

# Create the scatter plot for points vs cost
@df allriderdata Plots.scatter(
    :jittered_cost,
    :points,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Final Points",
    title="Final Performance: Points vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
```

The table below shows the top 15 point scorers from the race, who form the top end of the chart above.

```{julia}
#| echo: false

# Show top 15 point scorers from the whole race
top_scorers = sort(allriderdata, :points, rev=true)[1:15, :]
top_scorers_display = select(top_scorers, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints)
top_scorers_display[!, :FinalPoints] = Int.(round.(top_scorers_display.FinalPoints))
top_scorers_display[!, :Value] = round.(top_scorers_display.FinalPoints ./ top_scorers_display.Cost, digits=2)
markdown_table(top_scorers_display)
```

### Value vs Cost

Next, we'll examine rider value (points per credit) against their cost. This view is crucial for identifying the most efficient, value-for-money riders in the game.

```{julia}
#| echo: false
#| fig-cap: "Plot of rider value (points per credit) versus cost, coloured by rider classification."

# Create the scatter plot for value vs cost
@df allriderdata Plots.scatter(
    :jittered_cost,
    :value,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Value (Points per Credit)",
    title="Final Value: Points/Cost vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
```

The table below shows the best value riders from the race - those who delivered the most points per credit spent.

```{julia}
#| echo: false

# Show top 15 value riders (minimum 50 points to avoid noise from very cheap riders)
value_riders = filter(row -> row.points >= 50, allriderdata)
top_value = sort(value_riders, :value, rev=true)[1:min(15, nrow(value_riders)), :]
top_value_display = select(top_value, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :Value)
top_value_display[!, :FinalPoints] = Int.(round.(top_value_display.FinalPoints))
top_value_display[!, :Value] = round.(top_value_display.Value, digits=2)
markdown_table(top_value_display)
```

### High-Cost Underperformers

Finally, let's look at the riders who failed to deliver on their high costs - the biggest disappointments of the Vuelta a España 2025.

```{julia}
#| echo: false

# Show the worst value riders among expensive picks (cost >= 8)
expensive_riders = filter(row -> row.cost >= 8, allriderdata)
worst_value = sort(expensive_riders, :value)[1:min(10, nrow(expensive_riders)), :]
worst_value_display = select(worst_value, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :Value)
worst_value_display[!, :FinalPoints] = Int.(round.(worst_value_display.FinalPoints))
worst_value_display[!, :Value] = round.(worst_value_display.Value, digits=2)
markdown_table(worst_value_display)
```

### Distribution by Classification

Let's examine how the different rider classifications performed:

```{julia}
#| echo: false

# Summary statistics by class
class_summary = combine(groupby(allriderdata, :class),
    :points => (x -> round(mean(x), digits=1)) => :AvgPoints,
    :points => (x -> round(median(x), digits=1)) => :MedianPoints,
    :cost => (x -> round(mean(x), digits=1)) => :AvgCost,
    :value => (x -> round(mean(x), digits=2)) => :AvgValue,
    nrow => :Count
)

rename!(class_summary, :class => :Classification)
markdown_table(class_summary)
```

```{julia}
#| echo: false
#| fig-cap: "Box plot showing the distribution of points by rider classification."

# Create box plot of points by class
@df allriderdata StatsPlots.boxplot(
    :class,
    :points,
    xlabel="Classification",
    ylabel="Final Points",
    title="Points Distribution by Classification",
    size=(800, 600),
    dpi=300
)
```
