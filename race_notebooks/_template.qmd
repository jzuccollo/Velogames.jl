---
title: "RACE_NAME YEAR Team Optimization"
subtitle: "Prediction and team building"
execute:
    cache: false
freeze: false
---

## Quick Start Guide

**Instructions for using this template:**

1. Copy this file to a new name (e.g., `vuelta2025.qmd`)
2. Update the configuration section below:
   - Change `RACE_NAME` and `YEAR`
   - Set `RACE_TYPE` (`:stage` or `:oneday`)
   - Adjust source weights as needed
3. Run the notebook!

## Configuration

```{julia}
#| echo: false
using Velogames, DataFrames, Statistics, StatsBase, Printf, Markdown, MarkdownTables

# ===================================================================
# EDIT THESE LINES FOR YOUR RACE
# ===================================================================

RACE_NAME = "vuelta"  # Options: "tdf", "vuelta", "giro", "roubaix", "liege", etc.
YEAR = 2025
RACE_TYPE = :stage    # :stage for Grand Tours, :oneday for classics

# ===================================================================
# Quick race setup (auto-generates URLs and cache)
# ===================================================================

race = setup_race(RACE_NAME, YEAR, RACE_TYPE)

# ===================================================================
# Scoring sources - adjust weights to taste
# ===================================================================
# Weights should sum to something reasonable (0.0 - 1.0 range)
# A weight of 0.0 means "load this data but don't use it for scoring"

sources = [
    # Current race roster (weight 0 = just for baseline data)
    (name="current", kind=:vg_current, url=race.current_url, weight=0.0),

    # Previous year's results
    (name="vg_prev1", kind=:vg_past, url=get_historical_url(race, 1), weight=0.3),

    # Two years ago (optional - comment out if not needed)
    # (name="vg_prev2", kind=:vg_past, url=get_historical_url(race, 2), weight=0.2),

    # ProCyclingStats general rankings
    (name="pcs", kind=:pcs_current, url=nothing, weight=0.7),

    # Race-specific PCS rankings (if available - update URL)
    # (name="pcs_race", kind=:pcs_race, url="https://www.procyclingstats.com/race/RACE-NAME/YEAR/startlist", weight=0.5),
]

# ===================================================================
# Manual rider controls (optional)
# ===================================================================

# Force include these riders (exact names from Velogames)
include_riders = String[]
# Example:
# include_riders = ["Tadej Pogačar", "Jonas Vingegaard"]

# Exclude these riders (injuries, team selection, personal preference)
exclude_riders = String[]
# Example:
# exclude_riders = ["Rider Name"]

# ===================================================================
# Display configuration summary
# ===================================================================

println("=" ^ 60)
println("CONFIGURATION SUMMARY")
println("=" ^ 60)
display(Markdown.parse("""
**Race:** $(titlecase(RACE_NAME)) $YEAR
**Type:** $(RACE_TYPE == :stage ? "Stage Race" : "One-Day Race")
**Team Size:** $(race.team_size) riders
**Budget:** 100 credits

**Manual Overrides:**
- Force include: $(isempty(include_riders) ? "none" : join(include_riders, ", "))
- Exclude: $(isempty(exclude_riders) ? "none" : join(exclude_riders, ", "))
"""))

display(markdown_table(DataFrame(
    name=[s.name for s in sources],
    kind=[String(s.kind) for s in sources],
    weight=[s.weight for s in sources]
), String))
println("=" ^ 60)
```

## Load and Merge Data Sources

```{julia}
#| echo: false
#| output: false

# Validate that we have at least one vg_current source
if !any(src -> src.kind == :vg_current, sources)
    error("Must have at least one :vg_current source as the base roster")
end

# Load each source
function load_source(src)
    name, kind, url = src.name, src.kind, src.url

    try
        if kind == :vg_current
            df = getvgriders(url; cache_config=race.cache)
            rename!(df, :points => :current_points, :cost => :vg_cost)
            return (name=name, kind=kind, ok=true, df=df)

        elseif kind == :vg_past
            df = getvgriders(url; cache_config=race.cache)
            col = Symbol("points_", name)
            df = select(df, :riderkey, :rider, :team, :classraw, :points => col)
            return (name=name, kind=kind, ok=true, df=df)

        elseif kind == :pcs_current
            df = getpcsranking("me", "individual"; cache_config=race.cache)
            col = Symbol("pcs_points_", name)
            df = select(df, :riderkey, :rider, :points => col)
            return (name=name, kind=kind, ok=true, df=df)

        elseif kind == :pcs_race
            df = getpcsraceranking(url; cache_config=race.cache)
            col = Symbol("pcs_points_", name)
            # Handle various PCS race ranking formats
            if :pcspoints in names(df)
                df = select(df, [:riderkey, :rider, :pcspoints => col])
            elseif :points in names(df)
                df = select(df, :riderkey, :rider, :points => col)
            end
            return (name=name, kind=kind, ok=true, df=df)
        else
            return (name=name, kind=kind, ok=false, df=DataFrame())
        end
    catch e
        @warn "Failed to load source: $name" exception=e
        return (name=name, kind=kind, ok=false, df=DataFrame())
    end
end

# Load all sources
loaded = [load_source(src) for src in sources]

# Build base data from vg_current
base_idx = findfirst(x -> x.kind == :vg_current && x.ok, loaded)
@assert base_idx !== nothing "Base :vg_current failed to load"

team_data = loaded[base_idx].df

# Required columns check
required_cols = [:rider, :riderkey, :vg_cost, :current_points]
for col in required_cols
    @assert col in Symbol.(names(team_data)) "Missing required column: $col"
end

# Join other successful sources
for src in loaded
    if src.ok && src.kind != :vg_current && ncol(src.df) > 0
        team_data = leftjoin(team_data, src.df, on=:riderkey)
    end
end

println("✓ Loaded $(nrow(team_data)) riders from $(sum([s.ok for s in loaded])) sources")
```

## Calculate Combined Score

```{julia}
#| echo: false

# Calculate weighted score from all sources
team_data.weighted_score = zeros(Float64, nrow(team_data))

for src in sources
    if src.weight > 0 && src.kind != :vg_current
        col_name = if src.kind == :vg_past
            Symbol("points_", src.name)
        else
            Symbol("pcs_points_", src.name)
        end

        if col_name in Symbol.(names(team_data))
            # Add weighted contribution (with missing → 0)
            team_data.weighted_score .+= src.weight .* coalesce.(team_data[!, col_name], 0.0)
        end
    end
end

# Normalize scores (z-score within dataset)
if std(team_data.weighted_score) > 0
    team_data.score_normalized = (team_data.weighted_score .- mean(team_data.weighted_score)) ./ std(team_data.weighted_score)
else
    team_data.score_normalized = team_data.weighted_score
end

# Final optimization score (higher is better)
team_data.calcscore = team_data.score_normalized

println("✓ Calculated weighted scores (mean: $(round(mean(team_data.calcscore), digits=2)), std: $(round(std(team_data.calcscore), digits=2)))")
```

## Apply Manual Overrides

```{julia}
#| echo: false

# Apply exclusions
if !isempty(exclude_riders)
    excluded_count = nrow(filter(row -> row.rider in exclude_riders, team_data))
    team_data = filter(row -> !(row.rider in exclude_riders), team_data)
    println("✓ Excluded $excluded_count riders: $(join(exclude_riders, ", "))")
end

# Note: Inclusions are handled via optimization constraints (would need custom solver)
# For now, just highlight them
if !isempty(include_riders)
    println("⚠️  Note: Force-include not yet implemented. Riders to manually include:")
    for rider in include_riders
        if rider in team_data.rider
            println("   - $rider")
        else
            @warn "   - $rider (NOT FOUND in roster!)"
        end
    end
end
```

## Build Optimal Team

```{julia}
#| echo: false

# Run optimization
if RACE_TYPE == :stage
    println("Running stage race optimization (9 riders, class constraints)...")
    result = buildmodelstage(team_data, race.team_size, :calcscore, :vg_cost; totalcost=100)
else
    println("Running one-day race optimization ($(race.team_size) riders)...")
    result = buildmodeloneday(team_data, race.team_size, :calcscore, :vg_cost; totalcost=100)
end

if result === nothing
    error("Optimization failed - check warnings above")
end

# Extract selected team
chosen_vec = [result[r] for r in team_data.rider]
team_data.chosen = chosen_vec .> 0.5
selected_team = filter(:chosen => ==(true), team_data)

# Display results
println()
println("=" ^ 60)
println("OPTIMAL TEAM")
println("=" ^ 60)
println("Total riders: $(nrow(selected_team))")
println("Total cost:   $(sum(selected_team.vg_cost)) / 100")
println("Predicted score: $(round(sum(selected_team.calcscore), digits=2))")

if RACE_TYPE == :stage
    println()
    println("Classification breakdown:")
    println("  All-rounders: $(sum(selected_team.class .== "allrounder"))")
    println("  Climbers:     $(sum(selected_team.class .== "climber"))")
    println("  Sprinters:    $(sum(selected_team.class .== "sprinter"))")
    println("  Unclassed:    $(sum(selected_team.class .== "unclassed"))")
end
println("=" ^ 60)
```

## Team Summary

```{julia}
#| echo: false

# Select columns for display
display_cols = [:rider, :team, :vg_cost, :current_points, :calcscore]
if RACE_TYPE == :stage
    display_cols = [:rider, :team, :classraw, :vg_cost, :current_points, :calcscore]
end

# Filter to columns that exist
display_cols = [col for col in display_cols if col in Symbol.(names(selected_team))]

# Create display table
display_team = selected_team[:, display_cols]

# Rename for readability
rename_map = Dict(
    :classraw => :class,
    :vg_cost => :cost,
    :current_points => :pts_now,
    :calcscore => :predicted
)

for (old, new) in rename_map
    if old in Symbol.(names(display_team))
        rename!(display_team, old => new)
    end
end

# Sort by predicted score (descending)
if :predicted in Symbol.(names(display_team))
    sort!(display_team, :predicted, rev=true)
end

# Display as markdown table
display(markdown_table(display_team, String))
```

## Key Riders Analysis

```{julia}
#| echo: false

# Show top scorers NOT selected (potential value picks)
not_selected = filter(:chosen => ==(false), team_data)
sort!(not_selected, :calcscore, rev=true)

println()
println("Top 10 riders NOT selected (consider if you disagree with predictions):")
display(markdown_table(
    first(select(not_selected, :rider, :team, :vg_cost, :calcscore), 10),
    String
))
```

## Notes & Next Steps

**After the team is selected:**

- Review the selected team above
- Check "Top riders NOT selected" for potential manual swaps
- Update `include_riders` or `exclude_riders` if needed
- Adjust source weights if predictions seem off
- Re-run the notebook to see updated team

**For historical analysis:**

- After the race completes, update `current_url` to use actual results
- Change optimization to use `:points` instead of `:calcscore`
- Compare optimal team vs. your actual picks

---

*Generated with Velogames.jl - Optimize your fantasy cycling teams!*
