---
title: "Tour de France 2025: A Fantasy Retrospective"
subtitle: "A fantasy retrospective on the key performers and the perfect team"
format:
  html:
    code-fold: false
    toc: true
---

The Tour de France 2025 has concluded. This analysis examines the fantasy competition results, identifying the highest-performing riders and the optimal team composition using complete race data.

```{julia}
#| echo: false
#| output: false
#| cache: true

using Velogames, DataFrames, MarkdownTables, Markdown, Plots, StatsPlots, Statistics, Random

plotly() # Use Plotly backend for interactive plots

diagnostics_enabled = false
log_if_enabled(msg) = diagnostics_enabled && println(msg)

# Race configuration - Tour de France 2025 Final analysis
ridersurl = "https://www.velogames.com/velogame/2025/riders.php"
league_winner = "Marc Rediot"
winning_score = 11048

# Create TDF final analysis cache
tdf_final_cache = CacheConfig("/tmp/tdf_final_2025", 6, true)

# Data loading and initial processing
allriderdata = getvgriders(ridersurl; cache_config=tdf_final_cache)
rider_names = collect(allriderdata.rider)
pcs_df = getpcsriderpts_batch(rider_names; cache_config=tdf_final_cache)
vg_class_to_pcs_col = Dict(
    "allrounder" => "gc",
    "climber" => "climber",
    "sprinter" => "sprint",
    "unclassed" => "oneday",
)
add_pcs_speciality_points!(allriderdata, pcs_df, vg_class_to_pcs_col)

log_if_enabled("Starting optimization with $(nrow(allriderdata)) riders")
log_if_enabled("Total points available: $(sum(allriderdata.points))")
log_if_enabled("Riders with points > 0: $(sum(allriderdata.points .> 0))")
log_if_enabled("Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")

if any(ismissing.(allriderdata.points)) || any(ismissing.(allriderdata.cost))
    log_if_enabled("âš ï¸ Warning: Missing values detected in points or cost columns")
end

class_mapping = Dict(
    "allrounder" => "All rounder",
    "climber" => "Climber",
    "sprinter" => "Sprinter",
    "unclassed" => "Unclassed",
)
allriderdata.class = [get(class_mapping, class, class) for class in allriderdata.class]
log_if_enabled("Classes after normalisation: $(unique(allriderdata.class))")

solution = buildmodelhistorical(allriderdata, 9, :points, :cost; totalcost=100)
optimization_status = solution === nothing ? "fallback" : "optimal"

if solution === nothing
    log_if_enabled("âŒ Optimization failed, reverting to points-based selection.")
    chosenteam = sort(allriderdata, :points, rev=true)[1:9, :]
    allriderdata.chosen = [rider in chosenteam.rider for rider in allriderdata.rider]
else
    chosen_values = [solution[rider] > 0.5 for rider in allriderdata.rider]
    allriderdata.chosen = chosen_values
    chosenteam = subset(allriderdata, :chosen => ByRow(identity))
end

class_summary = class_availability_summary(allriderdata)
class_summary_lines = describe_class_availability(class_summary)

if diagnostics_enabled
    log_if_enabled("Constraint feasibility snapshot:")
    foreach(line -> log_if_enabled(line), class_summary_lines)
end

if winning_score > 0
    costsolution = minimizecostforstage(allriderdata, winning_score, 9, :cost; totalcost=100)
    if costsolution !== nothing
        chosen2_values = [costsolution[rider] > 0.5 for rider in allriderdata.rider]
        allriderdata.chosen2 = chosen2_values
        chosen2team = subset(allriderdata, :chosen2 => ByRow(identity))
    else
        log_if_enabled("Cost minimization failed")
        chosen2team = DataFrame()
    end
else
    chosen2team = DataFrame()
end

allriderdata.value = allriderdata.points ./ allriderdata.cost

Random.seed!(42)
jitter_amount = 0.3
allriderdata.jittered_cost = allriderdata.cost .+ (rand(nrow(allriderdata)) .- 0.5) .* jitter_amount

hover_text = [
    "$(row.rider)<br>Team: $(unpipe(row.team))<br>Class: $(row.class)<br>Cost: $(row.cost)<br>Points: $(round(Int, row.points))<br>Value: $(round(row.value; digits=1))"
    for row in eachrow(allriderdata)
]
allriderdata.hover_text = hover_text

optimal_points = sum(chosenteam.points)
optimal_cost = sum(chosenteam.cost)
margin_to_winner = winning_score > 0 ? optimal_points - winning_score : missing

top_scorer = sort(chosenteam, :points, rev=true)[1, :]
value_leader = sort(allriderdata, [:value, :points], rev=true)[1, :]

summary_stats = (
    optimization_status=optimization_status,
    optimal_points=round(Int, optimal_points),
    optimal_cost=round(Int, optimal_cost),
    margin=margin_to_winner === missing ? missing : round(Int, margin_to_winner),
    top_scorer=(top_scorer.rider, round(Int, top_scorer.points)),
    value_leader=(value_leader.rider, round(value_leader.value; digits=1)),
)

summary_margin_label = summary_stats.margin === missing ? "Not applicable" : string(summary_stats.margin, " points")
summary_status_label = summary_stats.optimization_status == "optimal" ? "Direct optimisation succeeded." : "Fallback to top-nine points due to solver constraints."
```

## Executive Summary

- **Optimal team score**: `{julia} summary_stats.optimal_points` points for `{julia} summary_stats.optimal_cost` credits.
- **Margin vs league winner**: `{julia} summary_margin_label`.
- **Top scorer**: `{julia} summary_stats.top_scorer[1]` amassed `{julia} summary_stats.top_scorer[2]` points.
- **Best value pick**: `{julia} summary_stats.value_leader[1]` at `{julia} summary_stats.value_leader[2]` points per credit.
- **Model status**: `{julia} summary_status_label`

At the end of three weeks of racing, **`{julia} league_winner`** won our fantasy league with **`{julia} winning_score`** points.

# The benefit of hindsight

## Optimal team composition

Using complete race results, optimization analysis identifies the highest-scoring combination of nine riders within budget and classification constraints.

The optimal team would have scored `{julia} (sum(chosenteam.points))` points at a cost of `{julia} (sum(chosenteam.cost))` creditsâ€”`{julia} (sum(chosenteam.points) - winning_score)` points above the league winner.

```{julia}
#| echo: false

# Create and display the team table
perfect_team_display = format_display_table(
    chosenteam;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :ValuePerCredit),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 1),
    sort_by=(:points, true),
)
markdown_table(perfect_team_display)
```

```{julia}
#| echo: false
#| output: asis

top_contributors = sort(chosenteam, :points, rev=true)[1:min(3, nrow(chosenteam)), :]
contributor_summary = join([string(row.rider, " (+", round(Int, row.points), " pts)") for row in eachrow(top_contributors)], ", ")
contributor_text = "Top contributors to the margin: " * contributor_summary
display(Markdown.parse(contributor_text))
```

## Minimum winning cost

Analysis of the lowest-cost team capable of defeating the league winner.

This team scores `{julia} sum(chosen2team.points)` points and costs just `{julia} sum(chosen2team.cost)` credits.

```{julia}
#| echo: false

if nrow(chosen2team) > 0
    # Create and display the cheapest winning team table
    cheapest_team_display = format_display_table(
        chosen2team;
        columns=[:rider, :team, :class, :cost, :points, :value],
        rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :ValuePerCredit),
        round_to_int=[:points, :cost],
        round_digits=Dict(:value => 1),
        sort_by=(:points, true),
    )
    markdown_table(cheapest_team_display)
else
    display(Markdown.parse("Could not determine the cheapest winning team."))
end
```

## High-cost underperformers

These high-cost riders didn't deliver the points their price tags demanded over the three weeks of racing:

```{julia}
#| echo: false

# Show expensive riders (8+ credits) with low points (under 200)
expensive_riders = subset(allriderdata, :cost => ByRow(x -> x >= 8))
disappointments = subset(expensive_riders, :points => ByRow(x -> x < 200))

if nrow(disappointments) > 0
    disappointments_display = format_display_table(
        disappointments;
        columns=[:rider, :team, :class, :cost, :points, :value],
        rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :ValuePerCredit),
        round_to_int=[:points, :cost],
        round_digits=Dict(:value => 1),
        sort_by=(:points, false),
    )
    markdown_table(disappointments_display)
else
    display(Markdown.parse("All expensive riders performed well!"))
end
```

# Performance analysis

The race has given us insights into which types of riders and strategies paid off. Let's break down the performance by cost and classification to see what's working.

### Points vs Cost

First, let's look at the raw performance: how many points each rider scored versus their cost. This helps us identify the high-scorers at every price point.

```{julia}
#| echo: false
#| fig-cap: "Plot of final points versus rider cost, coloured by rider classification."
#| cache: true

# Create the scatter plot for points vs cost
avg_points = mean(allriderdata.points)
points_vs_cost_plot = @df allriderdata Plots.scatter(
    :jittered_cost,
    :points,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Final Points",
    title="Final Performance: Points vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
Plots.hline!(points_vs_cost_plot, [avg_points]; color=:gray, linestyle=:dash, label="Average points")
points_vs_cost_plot
```

The table below shows the top 15 point scorers from the race, who form the top end of the chart above.

```{julia}
#| echo: false

# Show top 15 point scorers from the whole race
top_scorers = sort(allriderdata, :points, rev=true)[1:15, :]
top_scorers_display = format_display_table(
    top_scorers;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :ValuePerCredit),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 1),
    sort_by=(:points, true),
)
markdown_table(top_scorers_display)
```

### Value vs Cost

Next, we'll examine rider value (points per credit) against their cost. This view is crucial for identifying the most efficient, value-for-money riders in the game.

```{julia}
#| echo: false
#| fig-cap: "Plot of rider value (points per credit) versus cost, coloured by rider classification."
#| cache: true

# Create the scatter plot for value vs cost and make it static
avg_value = mean(allriderdata.value)
p_value = @df allriderdata Plots.scatter(
    :jittered_cost,
    :value,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Value (Points per Credit)",
    title="Final Value: Points/Cost vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300,
    config=Dict("staticPlot" => true)
)
p_value = Plots.hline!(p_value, [avg_value]; color=:gray, linestyle=:dash, label="Average value")
p_value
```

These riders have outperformed their cost expectations, delivering exceptional value over the entire Tour. The table below shows all riders who achieved a value of over 100 points per credit.

```{julia}
#| echo: false

# Calculate value and show all riders with a value over 100
high_value_performers = subset(allriderdata, :value => ByRow(x -> x > 100))
top_value = sort(high_value_performers, :value, rev=true)
top_value_display = format_display_table(
    top_value;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :ValuePerCredit),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 1),
    sort_by=(:value, true),
)
markdown_table(top_value_display)
```

## 2025 vs historical performance

Some riders overperformed compared to their historical averages, while others underperformed. This section compares the 2025 Tour de France performance against riders' VeloGames performances in 2024 and 2023.

```{julia}
#| echo: false
#| cache: true

log_if_enabled("ðŸ“Š Collecting historical Tour de France data for comparison...")

# Historical Tour de France data sources (from stage race predictor)
tdf_2024_url = "https://www.velogames.com/velogame/2024/riders.php"
tdf_2023_url = "https://www.velogames.com/velogame/2023/riders.php"

# Get historical data
log_if_enabled("ðŸ“¥ Fetching 2024 Tour de France results...")
try
    global tdf_2024_historical = getvgriders(tdf_2024_url; cache_config=tdf_final_cache)
    tdf_2024_historical = select(tdf_2024_historical, :riderkey, :rider, :points => :points_2024)
    log_if_enabled("   âœ… 2024 Tour data: $(nrow(tdf_2024_historical)) riders")
    global has_2024_historical = true
catch e
    log_if_enabled("   âš ï¸ 2024 Tour data unavailable: $(string(e))")
    global tdf_2024_historical = DataFrame(riderkey=String[], rider=String[], points_2024=Float64[])
    global has_2024_historical = false
end

log_if_enabled("ðŸ“¥ Fetching 2023 Tour de France results...")
try
    global tdf_2023_historical = getvgriders(tdf_2023_url; cache_config=tdf_final_cache)
    tdf_2023_historical = select(tdf_2023_historical, :riderkey, :rider, :points => :points_2023)
    log_if_enabled("   âœ… 2023 Tour data: $(nrow(tdf_2023_historical)) riders")
    global has_2023_historical = true
catch e
    log_if_enabled("   âš ï¸ 2023 Tour data unavailable: $(string(e))")
    global tdf_2023_historical = DataFrame(riderkey=String[], rider=String[], points_2023=Float64[])
    global has_2023_historical = false
end

# Merge historical data with 2025 results
historical_comparison = allriderdata[:, [:riderkey, :rider, :team, :class, :cost, :points]]
rename!(historical_comparison, :points => :points_2025)

if has_2024_historical
    historical_comparison = leftjoin(historical_comparison, tdf_2024_historical, on=:riderkey, makeunique=true)
    log_if_enabled("   âœ… Added 2024 data to comparison")
else
    historical_comparison[!, :points_2024] = zeros(Float64, nrow(historical_comparison))
    log_if_enabled("   âš ï¸ Using zeros for 2024 data")
end

if has_2023_historical
    historical_comparison = leftjoin(historical_comparison, tdf_2023_historical, on=:riderkey, makeunique=true)
    log_if_enabled("   âœ… Added 2023 data to comparison")
else
    historical_comparison[!, :points_2023] = zeros(Float64, nrow(historical_comparison))
    log_if_enabled("   âš ï¸ Using zeros for 2023 data")
end

# Handle missing values
for col in [:points_2024, :points_2023]
    if hasproperty(historical_comparison, col)
        historical_comparison[ismissing.(historical_comparison[!, col]), col] .= 0.0
        historical_comparison[!, col] = Float64.(historical_comparison[!, col])
    else
        historical_comparison[!, col] = zeros(Float64, nrow(historical_comparison))
    end
end

# Calculate historical averages and performance changes
historical_comparison[!, :historical_avg] = (historical_comparison.points_2024 .+ historical_comparison.points_2023) ./ 2
historical_comparison[!, :performance_change] = historical_comparison.points_2025 .- historical_comparison.historical_avg
historical_comparison[!, :performance_ratio] = historical_comparison.points_2025 ./ (historical_comparison.historical_avg .+ 1e-6)  # Avoid division by zero

# Filter to riders with meaningful historical data (participated in at least one previous Tour)
meaningful_riders = subset(historical_comparison, [:points_2024, :points_2023] => ByRow((p2024, p2023) -> (p2024 + p2023) > 0))

log_if_enabled("ðŸ“ˆ Historical comparison complete: $(nrow(meaningful_riders)) riders with historical Tour data")
```

### Performance vs Historical Average: Above-Average Riders

These riders significantly exceeded their 2023-2024 Tour de France averages in 2025:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Top overperformers (minimum 100 point improvement to filter noise)
    overperformers = subset(meaningful_riders, :performance_change => ByRow(x -> x >= 100))
    top_overperformers = sort(overperformers, :performance_change, rev=true)[1:min(15, nrow(overperformers)), :]

    if nrow(top_overperformers) > 0
        overperform_display = format_display_table(
            top_overperformers;
            columns=[:rider, :team, :class, :cost, :points_2025, :historical_avg, :performance_change],
            rename_map=Dict(
                :rider => :Rider,
                :team => :Team,
                :class => :Class,
                :cost => :Cost,
                :points_2025 => :Points2025,
                :historical_avg => :HistoricalAvg,
                :performance_change => :Improvement,
            ),
            round_to_int=[:points_2025, :historical_avg, :performance_change, :cost],
            sort_by=(:performance_change, true),
        )
        markdown_table(overperform_display)
    else
        display(Markdown.parse("No riders with significant overperformance (â‰¥100 points) found."))
    end
else
    display(Markdown.parse("No riders with historical data available for comparison."))
end
```

### Performance vs Historical Average: Below-Average Riders

These riders fell well short of their 2023-2024 Tour de France averages:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Top underperformers (minimum -100 point decline to filter noise)
    underperformers = subset(meaningful_riders, :performance_change => ByRow(x -> x <= -100))
    top_underperformers = sort(underperformers, :performance_change)[1:min(15, nrow(underperformers)), :]

    if nrow(top_underperformers) > 0
        underperform_display = format_display_table(
            top_underperformers;
            columns=[:rider, :team, :class, :cost, :points_2025, :historical_avg, :performance_change],
            rename_map=Dict(
                :rider => :Rider,
                :team => :Team,
                :class => :Class,
                :cost => :Cost,
                :points_2025 => :Points2025,
                :historical_avg => :HistoricalAvg,
                :performance_change => :Decline,
            ),
            round_to_int=[:points_2025, :historical_avg, :performance_change, :cost],
            sort_by=(:performance_change, false),
        )
        markdown_table(underperform_display)
    else
        display(Markdown.parse("No riders with significant underperformance (â‰¤-100 points) found."))
    end
else
    display(Markdown.parse("No riders with historical data available for comparison."))
end
```

### Performance Change Distribution

```{julia}
#| echo: false
#| fig-cap: "Distribution of 2025 performance changes compared to 2023-2024 historical averages"

if nrow(meaningful_riders) > 0
    # Create histogram of performance changes
    histogram(meaningful_riders.performance_change,
        bins=30,
        xlabel="Performance Change vs Historical Average (Points)",
        ylabel="Number of Riders",
        title="2025 Tour Performance vs 2023-2024 Average",
        legend=false,
        alpha=0.7,
        size=(800, 500),
        dpi=300
    )

    # Add vertical line at zero
    vline!([0], color=:red, linestyle=:dash, linewidth=2, label="No Change")
else
    display(Markdown.parse("No historical data available for performance change analysis."))
end
```

### Year-over-Year Performance Matrix

This table shows the three-year performance pattern for riders who participated in all three Tours:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Filter to riders who participated in all three years (non-zero points)
    three_year_riders = subset(meaningful_riders, [:points_2023, :points_2024, :points_2025] => ByRow((p2023, p2024, p2025) -> p2023 > 0 && p2024 > 0 && p2025 > 0))

    if nrow(three_year_riders) > 0
        # Sort by 2025 performance and show top performers
        three_year_top = sort(three_year_riders, :points_2025, rev=true)[1:min(20, nrow(three_year_riders)), :]

        three_year_table = format_display_table(
            three_year_top;
            columns=[:rider, :team, :class, :points_2023, :points_2024, :points_2025, :historical_avg, :performance_change],
            rename_map=Dict(
                :rider => :Rider,
                :team => :Team,
                :class => :Class,
                :points_2023 => :Tour2023,
                :points_2024 => :Tour2024,
                :points_2025 => :Tour2025,
                :historical_avg => :HistoricalAvg,
                :performance_change => Symbol("Change vs Avg"),
            ),
            round_to_int=[:points_2023, :points_2024, :points_2025, :historical_avg, :performance_change],
            sort_by=(:points_2025, true),
        )

        trend_flags = Vector{String}(undef, nrow(three_year_top))
        for (idx, row) in enumerate(eachrow(three_year_top))
            if row.points_2025 < row.points_2024 < row.points_2023
                trend_flags[idx] = "ðŸ“‰"
            elseif row.points_2025 > row.points_2024 > row.points_2023
                trend_flags[idx] = "ðŸ“ˆ"
            else
                trend_flags[idx] = "ðŸ“Š"
            end
        end

        three_year_table[!, :Trend] = trend_flags
        markdown_table(three_year_table)
        display(Markdown.parse("ðŸ“ˆ = Improving trend, ðŸ“‰ = Declining trend, ðŸ“Š = Mixed performance"))
    else
        display(Markdown.parse("No riders found who participated in all three Tours (2023, 2024, 2025)."))
    end
else
    display(Markdown.parse("Insufficient historical data for three-year comparison."))
end
```

