---
title: "Vuelta a España 2025: A Fantasy Retrospective"
subtitle: "A fantasy retrospective on the key performers and the perfect team"
format:
  html:
    code-fold: false
    toc: true
---

The Vuelta a España 2025 has concluded. This analysis examines the fantasy competition results, identifying the highest-performing riders and the optimal team composition using complete race data.

```{julia}
#| echo: false
#| output: false
#| cache: true

using Velogames, DataFrames, MarkdownTables, Markdown, Plots, StatsPlots, Statistics, Random

plotly() # Use Plotly backend for interactive plots

diagnostics_enabled = false
log_if_enabled(msg) = diagnostics_enabled && println(msg)

# Race configuration - Vuelta a España 2025 Final analysis
ridersurl = "https://www.velogames.com/spain/2025/riders.php"
league_winner = "Salsa Tequila"
winning_score = 10965

# Create Vuelta final analysis cache
vuelta_final_cache = CacheConfig("/tmp/vuelta_final_2025", 6, true)

# Data loading and initial processing
allriderdata = getvgriders(ridersurl; cache_config=vuelta_final_cache)
rider_names = collect(allriderdata.rider)
pcs_df = getpcsriderpts_batch(rider_names; cache_config=vuelta_final_cache)
vg_class_to_pcs_col = Dict(
    "allrounder" => "gc",
    "climber" => "climber",
    "sprinter" => "sprint",
    "unclassed" => "oneday",
)
add_pcs_speciality_points!(allriderdata, pcs_df, vg_class_to_pcs_col)

log_if_enabled("Starting optimization with $(nrow(allriderdata)) riders")
log_if_enabled("Total points available: $(sum(allriderdata.points))")
log_if_enabled("Riders with points > 0: $(sum(allriderdata.points .> 0))")
log_if_enabled("Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")

if any(ismissing.(allriderdata.points)) || any(ismissing.(allriderdata.cost))
    log_if_enabled("⚠️ Warning: Missing values detected in points or cost columns")
end

class_mapping = Dict(
    "allrounder" => "All rounder",
    "climber" => "Climber",
    "sprinter" => "Sprinter",
    "unclassed" => "Unclassed",
)
allriderdata.class = [get(class_mapping, class, class) for class in allriderdata.class]
log_if_enabled("Classes after normalisation: $(unique(allriderdata.class))")

solution = buildmodelhistorical(allriderdata, 9, :points, :cost; totalcost=100)
optimization_status = solution === nothing ? "fallback" : "optimal"

if solution === nothing
    log_if_enabled("❌ Optimization failed, reverting to points-based selection.")
    chosenteam = sort(allriderdata, :points, rev=true)[1:9, :]
    allriderdata.chosen = [rider in chosenteam.rider for rider in allriderdata.rider]
else
    chosen_values = [solution[rider] > 0.5 for rider in allriderdata.rider]
    allriderdata.chosen = chosen_values
    chosenteam = subset(allriderdata, :chosen => ByRow(identity))
end

class_summary = class_availability_summary(allriderdata)
class_summary_lines = describe_class_availability(class_summary)

if diagnostics_enabled
    log_if_enabled("Constraint feasibility snapshot:")
    foreach(line -> log_if_enabled(line), class_summary_lines)
end

if winning_score > 0
    costsolution = minimizecostforstage(allriderdata, winning_score, 9, :cost; totalcost=100)
    if costsolution !== nothing
        chosen2_values = [costsolution[rider] > 0.5 for rider in allriderdata.rider]
        allriderdata.chosen2 = chosen2_values
        chosen2team = subset(allriderdata, :chosen2 => ByRow(identity))
    else
        log_if_enabled("Cost minimization failed")
        chosen2team = DataFrame()
    end
else
    chosen2team = DataFrame()
end

allriderdata.value = allriderdata.points ./ allriderdata.cost

Random.seed!(42)
jitter_amount = 0.5
allriderdata.jittered_cost = allriderdata.cost .+ (rand(nrow(allriderdata)) .- 0.5) .* jitter_amount

allriderdata.hover_text = [
    "$(row.rider)\n$(row.team)\n$(row.class)\nCost: $(row.cost)\nPoints: $(round(row.points, digits=1))\nValue: $(round(row.value, digits=2))"
    for row in eachrow(allriderdata)
]

optimal_points = sum(chosenteam.points)
optimal_cost = sum(chosenteam.cost)
margin_to_winner = winning_score > 0 ? optimal_points - winning_score : missing

top_scorer = sort(chosenteam, :points, rev=true)[1, :]
value_leader = sort(allriderdata, [:value, :points], rev=true)[1, :]

summary_stats = (
    optimization_status=optimization_status,
    optimal_points=round(Int, optimal_points),
    optimal_cost=round(Int, optimal_cost),
    margin=margin_to_winner === missing ? missing : round(Int, margin_to_winner),
    top_scorer=(top_scorer.rider, round(Int, top_scorer.points)),
    value_leader=(value_leader.rider, round(value_leader.value; digits=2)),
)

summary_margin_label = summary_stats.margin === missing ? "Not applicable" : string(summary_stats.margin, " points")
summary_status_label = summary_stats.optimization_status == "optimal" ? "Direct optimisation succeeded." : "Fallback to top-nine points due to solver constraints."
```

## Executive Summary

- **Optimal team score**: `{julia} summary_stats.optimal_points` points for `{julia} summary_stats.optimal_cost` credits.
- **Margin vs league winner**: `{julia} summary_margin_label`.
- **Top scorer**: `{julia} summary_stats.top_scorer[1]` delivered `{julia} summary_stats.top_scorer[2]` points.
- **Best value pick**: `{julia} summary_stats.value_leader[1]` at `{julia} summary_stats.value_leader[2]` points per credit.
- **Model status**: `{julia} summary_status_label`

## League Performance Benchmark

The winning team in our league, **`{julia} league_winner`**, scored **`{julia} winning_score`** points. This is the benchmark for our retrospective analysis.

## Optimal Team Composition

Using complete race results, optimization analysis identifies the highest-scoring combination of nine riders within budget and classification constraints. The optimal team would have scored **`{julia} Int(round(sum(chosenteam.points)))`** points at a cost of **`{julia} Int(sum(chosenteam.cost))`** credits.

```{julia}
#| echo: false
#| output: asis

message = nothing
if winning_score > 0 && sum(chosenteam.points) > winning_score
    margin = Int(round(sum(chosenteam.points) - winning_score))
    message = "This represents a $(margin)-point improvement over the league winner."
elseif winning_score > 0
    margin = Int(round(sum(chosenteam.points) - winning_score))
    message = "This would have been sufficient to win by $(margin) points."
end

if message !== nothing
    display(Markdown.parse(message))
end
```

Here is the optimal team:

```{julia}
#| echo: false

# Create and display the optimal team table
displaytable = format_display_table(
    chosenteam;
    columns=[:rider, :team, :class, :cost, :points],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :Score),
    round_to_int=[:points, :cost],
    sort_by=(:points, true),
)
markdown_table(displaytable)
# Close table chunk before printing summary
```

```{julia}
#| echo: false
#| output: asis

top_contributors = sort(chosenteam, :points, rev=true)[1:min(3, nrow(chosenteam)), :]
contributor_summary = join([string(row.rider, " (+", round(Int, row.points), " pts)") for row in eachrow(top_contributors)], ", ")
display(Markdown.parse("Top contributors to the margin: " * contributor_summary))
```


```{julia}
#| echo: false
#| output: asis

if !isempty(chosen2team) && winning_score > 0
    cost_points = Int(round(sum(chosen2team.points)))
    cost_credits = Int(sum(chosen2team.cost))

    section_text = join([
            "## Minimum Winning Cost",
            "",
            "Analysis of the lowest-cost team capable of defeating the league winner. This team would have scored $(cost_points) points at a cost of $(cost_credits) credits.",
            "",
            "Minimum cost winning team:"
        ], "\n")
    display(Markdown.parse(section_text))

    displaytable2 = format_display_table(
        chosen2team;
        columns=[:rider, :team, :class, :cost, :points],
        rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :Score),
        round_to_int=[:points, :cost],
        sort_by=(:points, true),
    )
    table_md = sprint(io -> show(io, MIME"text/markdown"(), markdown_table(displaytable2)))
    display(Markdown.parse(table_md))
end
```

# Rider Value Analysis

This chart plots rider cost against points scored, showing the relationship between price and performance.

```{julia}
#| echo: false
#| fig-cap: "Plot of final race points versus rider cost, coloured by rider classification."

# Create the scatter plot for points vs cost
avg_points = mean(allriderdata.points)
points_vs_cost_plot = @df allriderdata Plots.scatter(
    :jittered_cost,
    :points,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Final Points",
    title="Final Performance: Points vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
Plots.hline!(points_vs_cost_plot, [avg_points]; color=:gray, linestyle=:dash, label="Average points")
points_vs_cost_plot
```

The table below shows the top 15 point scorers from the race, who form the top end of the chart above.

```{julia}
#| echo: false

# Show top 15 point scorers from the whole race
top_scorers = sort(allriderdata, :points, rev=true)[1:15, :]
top_scorers_display = format_display_table(
    top_scorers;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :Value),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 2),
    sort_by=(:points, true),
)
markdown_table(top_scorers_display)
```

### Value vs Cost

Next, we'll examine rider value (points per credit) against their cost. This view is crucial for identifying the most efficient, value-for-money riders in the game.

```{julia}
#| echo: false
#| fig-cap: "Plot of rider value (points per credit) versus cost, coloured by rider classification."

# Create the scatter plot for value vs cost
avg_value = mean(allriderdata.value)
value_vs_cost_plot = @df allriderdata Plots.scatter(
    :jittered_cost,
    :value,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=:hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Value (Points per Credit)",
    title="Final Value: Points/Cost vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
Plots.hline!(value_vs_cost_plot, [avg_value]; color=:gray, linestyle=:dash, label="Average value")
value_vs_cost_plot
```

The table below shows the best value riders from the race - those who delivered the most points per credit spent.

```{julia}
#| echo: false

# Show top 15 value riders (minimum 50 points to avoid noise from very cheap riders)
value_riders = subset(allriderdata, :points => ByRow(x -> x >= 50))
top_value = sort(value_riders, :value, rev=true)[1:min(15, nrow(value_riders)), :]
top_value_display = format_display_table(
    top_value;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :Value),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 2),
    sort_by=(:value, true),
)
markdown_table(top_value_display)
```

### High-Cost Underperformers

Finally, let's look at the riders who failed to deliver on their high costs - the biggest disappointments of the Vuelta a España 2025.

```{julia}
#| echo: false

# Show the worst value riders among expensive picks (cost >= 8)
expensive_riders = subset(allriderdata, :cost => ByRow(x -> x >= 8))
worst_value = sort(expensive_riders, :value)[1:min(10, nrow(expensive_riders)), :]
worst_value_display = format_display_table(
    worst_value;
    columns=[:rider, :team, :class, :cost, :points, :value],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :FinalPoints, :value => :Value),
    round_to_int=[:points, :cost],
    round_digits=Dict(:value => 2),
    sort_by=(:value, false),
)
markdown_table(worst_value_display)
```

### Distribution by Classification

Let's examine how the different rider classifications performed:

```{julia}
#| echo: false

# Summary statistics by class
class_stats = combine(groupby(allriderdata, :class),
    :points => (x -> round(mean(x), digits=1)) => :AvgPoints,
    :points => (x -> round(median(x), digits=1)) => :MedianPoints,
    :cost => (x -> round(mean(x), digits=1)) => :AvgCost,
    :value => (x -> round(mean(x), digits=2)) => :AvgValue,
    nrow => :Count
)

rename!(class_stats, :class => :Classification)
markdown_table(class_stats)
```

```{julia}
#| echo: false
#| fig-cap: "Box plot showing the distribution of points by rider classification."

# Create box plot of points by class
@df allriderdata StatsPlots.boxplot(
    :class,
    :points,
    xlabel="Classification",
    ylabel="Final Points",
    title="Points Distribution by Classification",
    size=(800, 600),
    dpi=300
)
```

## Impact on League Rankings: Points For and Against

The following sections show which riders had the biggest impact on league rankings, based on their points and ownership levels.

### Riders Sorted by "Points For"

Riders who delivered the most points to teams that owned them, weighted by the percentage of teams that did **not** own them. This highlights the riders who gave the biggest boost to their owners' league rankings.

```{julia}
#| echo: false
#| output: asis

# Calculate points_for = points * (1 - selected)
allriderdata.points_for = allriderdata.points .* (1 .- allriderdata.selected)
points_for_sorted = sort(allriderdata, :points_for, rev=true)[1:min(15, nrow(allriderdata)), :]
points_for_display = format_display_table(
    points_for_sorted;
    columns=[:rider, :team, :class, :cost, :points, :selected, :points_for],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :Points, :selected => :Selected, :points_for => :PointsFor),
    round_to_int=[:points, :cost, :points_for],
    sort_by=(:points_for, true),
)
selected_percentages = string.(round.(points_for_sorted.selected .* 100; digits=1), "%")
points_for_display[!, :Selected] = selected_percentages[1:nrow(points_for_display)]
markdown_table(points_for_display)

```

```{julia}
#| echo: false
#| output: asis

top_for = points_for_sorted[1:min(3, nrow(points_for_sorted)), :]
boost_summary = join([string(row.rider, " (+", round(Int, row.points_for), " pts)") for row in eachrow(top_for)], ", ")
display(Markdown.parse("Key boosts: " * boost_summary))
```


### Riders Sorted by "Points Against"

Riders who, by combining high ownership with high points, did the most damage to your league rank if you **didn't** own them. This is calculated as points * selected.

```{julia}
#| echo: false
#| output: asis

# Calculate points_against = points * selected
allriderdata.points_against = allriderdata.points .* allriderdata.selected
points_against_sorted = sort(allriderdata, :points_against, rev=true)[1:min(15, nrow(allriderdata)), :]
points_against_display = format_display_table(
    points_against_sorted;
    columns=[:rider, :team, :class, :cost, :points, :selected, :points_against],
    rename_map=Dict(:rider => :Rider, :team => :Team, :class => :Class, :cost => :Cost, :points => :Points, :selected => :Selected, :points_against => :PointsAgainst),
    round_to_int=[:points, :cost, :points_against],
    sort_by=(:points_against, true),
)
selected_against = string.(round.(points_against_sorted.selected .* 100; digits=1), "%")
points_against_display[!, :Selected] = selected_against[1:nrow(points_against_display)]
markdown_table(points_against_display)

```

```{julia}
#| echo: false
#| output: asis

top_against = points_against_sorted[1:min(3, nrow(points_against_sorted)), :]
pressure_summary = join([string(row.rider, " (", round(Int, row.points_against), " pts, ", round(row.selected * 100; digits=1), "% owned)") for row in eachrow(top_against)], ", ")
display(Markdown.parse("League pressure points: " * pressure_summary))
```

