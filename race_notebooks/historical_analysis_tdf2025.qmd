---
title: "Tour de France 2025: A Fantasy Retrospective"
subtitle: "A fantasy retrospective on the key performers and the perfect team"
format:
  html:
    code-fold: false
    toc: true
---

The Tour de France 2025 has concluded. This analysis examines the fantasy competition results, identifying the highest-performing riders and the optimal team composition using complete race data.

```{julia}
#| echo: false
#| output: false
#| cache: true

using Velogames, DataFrames, MarkdownTables, Plots, Printf, JuMP, HiGHS, StatsPlots, Statistics, Random

plotly() # Use Plotly backend for interactive plots

# Race configuration - Tour de France 2025 Final analysis
ridersurl = "https://www.velogames.com/velogame/2025/riders.php"
league_winner = "Marc Rediot"
winning_score = 11048

# Create TDF final analysis cache
tdf_final_cache = CacheConfig("/tmp/tdf_final_2025", 6, true)

# Data loading and initial processing
allriderdata = getvgriders(ridersurl; cache_config=tdf_final_cache)
rider_names = collect(allriderdata.rider)
pcs_df = getpcsriderpts_batch(rider_names; cache_config=tdf_final_cache)
vg_class_to_pcs_col = Dict(
    "allrounder" => "gc",
    "climber" => "climber",
    "sprinter" => "sprint",
    "unclassed" => "oneday"
)
add_pcs_speciality_points!(allriderdata, pcs_df, vg_class_to_pcs_col)

# Set up the optimization model for the best possible team using final results
println("Starting optimization with $(nrow(allriderdata)) riders")
println("Total points available: $(sum(allriderdata.points))")
println("Riders with points > 0: $(sum(allriderdata.points .> 0))")
println("Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")

# Check data quality before optimization
if any(ismissing.(allriderdata.points)) || any(ismissing.(allriderdata.cost))
    println("âš ï¸ Warning: Missing values detected in points or cost columns")
end

# Let's also try to understand the optimization problem better
println("\nDebug: Examining class structure...")
println("Unique classes in data: $(unique(allriderdata.class))")

# Fix class name mismatch - the optimization function expects title case
class_mapping = Dict(
    "allrounder" => "All rounder",
    "climber" => "Climber",
    "sprinter" => "Sprinter",
    "unclassed" => "Unclassed"
)

println("Fixing class names for optimization...")
allriderdata.class = [get(class_mapping, class, class) for class in allriderdata.class]
println("Updated classes: $(unique(allriderdata.class))")

solution = buildmodelhistorical(allriderdata, 9, :points, :cost; totalcost=100)
if solution !== nothing
    chosen_values = [solution[rider] > 0.5 for rider in allriderdata.rider]
    allriderdata.chosen = chosen_values
    chosenteam = filter(row -> row.chosen, allriderdata)
    println("âœ… Optimization successful: Found team with $(sum(chosenteam.points)) points, costing $(sum(chosenteam.cost)) credits")
else
    # More detailed diagnostic information if optimization fails
    println("âŒ Optimization failed.")
    println("\nDetailed diagnostic information:")
    println("Data summary:")
    println("- Total riders: $(nrow(allriderdata))")
    println("- Points range: $(minimum(allriderdata.points)) - $(maximum(allriderdata.points))")
    println("- Cost range: $(minimum(allriderdata.cost)) - $(maximum(allriderdata.cost))")
    println("- Unique classes: $(unique(allriderdata.class))")

    # Check if we have riders in each required class (use actual class names from data)
    class_counts = combine(groupby(allriderdata, :class), nrow => :count)
    println("\nClass distribution:")
    for row in eachrow(class_counts)
        println("  - $(row.class): $(row.count) riders")
    end

    # The issue might be that the class names don't match what the function expects
    # Let's manually check what classes we actually have
    expected_classes = ["All rounder", "Climber", "Sprinter", "Unclassed"]
    actual_classes = unique(allriderdata.class)
    println("\nClass name matching:")
    println("Expected classes: $(expected_classes)")
    println("Actual classes: $(actual_classes)")

    missing_classes = setdiff(expected_classes, actual_classes)
    if !isempty(missing_classes)
        println("âŒ Missing expected classes: $(missing_classes)")
        println("This is likely why optimization failed!")
    end

    # Proceed with fallback analysis without optimization
    println("\nProceeding with analysis using top performers instead of optimal team...")
    chosenteam = sort(allriderdata, :points, rev=true)[1:9, :]
    allriderdata.chosen = [rider in chosenteam.rider for rider in allriderdata.rider]
    println("Fallback team total points: $(sum(chosenteam.points))")
end

# Calculate current value and identify standout performers

# Let's also check constraint feasibility for debugging
println("Constraint feasibility check:")
println("Can we form a valid team?")

# Check if we can satisfy class constraints with budget - using corrected class names
allrounder_riders = filter(row -> row.class == "All rounder", allriderdata)
climber_riders = filter(row -> row.class == "Climber", allriderdata)
sprinter_riders = filter(row -> row.class == "Sprinter", allriderdata)
unclassed_riders = filter(row -> row.class == "Unclassed", allriderdata)

println("Available riders by class:")
println("- All rounders: $(nrow(allrounder_riders))")
if nrow(allrounder_riders) >= 2
    println("  Cheapest 2: $(sort(allrounder_riders.cost)[1:2])")
end
println("- Climbers: $(nrow(climber_riders))")
if nrow(climber_riders) >= 2
    println("  Cheapest 2: $(sort(climber_riders.cost)[1:2])")
end
println("- Sprinters: $(nrow(sprinter_riders))")
if nrow(sprinter_riders) >= 1
    println("  Cheapest: $(minimum(sprinter_riders.cost))")
end
println("- Unclassed: $(nrow(unclassed_riders))")
if nrow(unclassed_riders) >= 4
    println("  Cheapest 4: $(sort(unclassed_riders.cost)[1:4])")
end

# Check minimum cost for a valid team (2 AR, 2 C, 1 S, 4 U)
if nrow(allrounder_riders) >= 2 && nrow(climber_riders) >= 2 && nrow(sprinter_riders) >= 1 && nrow(unclassed_riders) >= 4
    min_cost = sum(sort(allrounder_riders.cost)[1:2]) + sum(sort(climber_riders.cost)[1:2]) + minimum(sprinter_riders.cost) + sum(sort(unclassed_riders.cost)[1:4])
    println("Minimum cost for a valid team: $(min_cost)")
else
    println("âŒ Insufficient riders in one or more classes!")
end

# Find the cheapest team that would have won the league (if winning_score > 0)
if winning_score > 0
    costsolution = minimizecostforstage(allriderdata, winning_score, 9, :cost; totalcost=100)
    if costsolution !== nothing
        chosen2_values = [costsolution[rider] > 0.5 for rider in allriderdata.rider]
        allriderdata.chosen2 = chosen2_values
        chosen2team = filter(row -> row.chosen2, allriderdata)
    else
        println("Cost minimization failed")
        chosen2team = DataFrame()
    end
else
    chosen2team = DataFrame() # No cost minimization analysis without a target score
end
```


At the end of three weeks of racing, **`{julia} league_winner`** won our fantasy league with **`{julia} winning_score`** points.

# The benefit of hindsight

## Optimal team composition

Using complete race results, optimization analysis identifies the highest-scoring combination of nine riders within budget and classification constraints.

The optimal team would have scored `{julia} (sum(chosenteam.points))` points at a cost of `{julia} (sum(chosenteam.cost))` creditsâ€”`{julia} (sum(chosenteam.points) - winning_score)` points above the league winner.

```{julia}
#| echo: false

# Create and display the team table
perfect_team_display = rename(chosenteam, :rider => :Rider, :team => :Team,
    :cost => :Cost, :points => :FinalPoints, :class => :Class)
perfect_team_display[!, :FinalPoints] = Int.(round.(perfect_team_display.FinalPoints))
perfect_team_display[!, :Value] = Int.(round.(perfect_team_display.FinalPoints ./ perfect_team_display.Cost))
markdown_table(perfect_team_display[:, [:Rider, :Team, :Class, :Cost, :FinalPoints, :Value]])
```

## Minimum winning cost

Analysis of the lowest-cost team capable of defeating the league winner.

This team scores `{julia} sum(chosen2team.points)` points and costs just `{julia} sum(chosen2team.cost)` credits.

```{julia}
#| echo: false

if nrow(chosen2team) > 0
    # Create and display the cheapest winning team table
    cheapest_team_display = rename(chosen2team, :rider => :Rider, :team => :Team,
        :cost => :Cost, :points => :FinalPoints, :class => :Class)
    cheapest_team_display[!, :FinalPoints] = Int.(round.(cheapest_team_display.FinalPoints))
    cheapest_team_display[!, :Value] = Int.(round.(cheapest_team_display.FinalPoints ./ cheapest_team_display.Cost))
    markdown_table(cheapest_team_display[:, [:Rider, :Team, :Class, :Cost, :FinalPoints, :Value]])
else
    println("Could not determine the cheapest winning team.")
end
```

## High-cost underperformers

These high-cost riders didn't deliver the points their price tags demanded over the three weeks of racing:

```{julia}
#| echo: false

# Show expensive riders (8+ credits) with low points (under 200)
expensive_riders = filter(row -> row.cost >= 8, allriderdata)
disappointments = filter(row -> row.points < 200, expensive_riders)
disappointments_display = select(disappointments, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints)
disappointments_display[!, :FinalPoints] = Int.(round.(disappointments_display.FinalPoints))
disappointments_display[!, :Value] = Int.(round.(disappointments_display.FinalPoints ./ disappointments_display.Cost))

if nrow(disappointments) > 0
    markdown_table(disappointments_display)
else
    println("All expensive riders performed well!")
end
```

# Performance analysis

The race has given us insights into which types of riders and strategies paid off. Let's break down the performance by cost and classification to see what's working.

### Points vs Cost

First, let's look at the raw performance: how many points each rider scored versus their cost. This helps us identify the high-scorers at every price point.

```{julia}
#| echo: false
#| fig-cap: "Plot of final points versus rider cost, coloured by rider classification."
#| cache: true

# Jitter cost for better visibility
Random.seed!(42)
allriderdata.jittered_cost = allriderdata.cost .+ (rand(nrow(allriderdata)) .- 0.5) .* 0.3

# Create hover text with original cost
hover_text = [
    "$(row.rider)<br>Team: $(row.team)<br>Class: $(row.class)<br>Cost: $(row.cost)<br>Points: $(@sprintf("%.0f", row.points))<br>Value: $(@sprintf("%.1f", row.value))"
    for row in eachrow(allriderdata)
]

# Create the scatter plot for points vs cost
@df allriderdata Plots.scatter(
    :jittered_cost,
    :points,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Final Points",
    title="Final Performance: Points vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300
)
```

The table below shows the top 15 point scorers from the race, who form the top end of the chart above.

```{julia}
#| echo: false

# Show top 15 point scorers from the whole race
top_scorers = sort(allriderdata, :points, rev=true)[1:15, :]
top_scorers_display = select(top_scorers, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints)
top_scorers_display[!, :FinalPoints] = Int.(round.(top_scorers_display.FinalPoints))
top_scorers_display[!, :Value] = Int.(round.(top_scorers_display.FinalPoints ./ top_scorers_display.Cost))
markdown_table(top_scorers_display)
```

### Value vs Cost

Next, we'll examine rider value (points per credit) against their cost. This view is crucial for identifying the most efficient, value-for-money riders in the game.

```{julia}
#| echo: false
#| fig-cap: "Plot of rider value (points per credit) versus cost, coloured by rider classification."
#| cache: true

# Create the scatter plot for value vs cost and make it static
p_value = @df allriderdata Plots.scatter(
    :jittered_cost,
    :value,
    group=:class,
    markerstrokewidth=0,
    alpha=0.7,
    hover=hover_text,
    xlabel="Cost (Jittered)",
    ylabel="Value (Points per Credit)",
    title="Final Value: Points/Cost vs Cost",
    legend=:topleft,
    size=(800, 600),
    dpi=300,
    config=Dict("staticPlot" => true)
)
p_value
```

These riders have outperformed their cost expectations, delivering exceptional value over the entire Tour. The table below shows all riders who achieved a value of over 100 points per credit.

```{julia}
#| echo: false

# Calculate value and show all riders with a value over 100
allriderdata.value = allriderdata.points ./ allriderdata.cost
high_value_performers = filter(row -> row.value > 100, allriderdata)
top_value = sort(high_value_performers, :value, rev=true)
top_value_display = select(top_value, :rider => :Rider, :team => :Team,
    :class => :Class, :cost => :Cost, :points => :FinalPoints)
top_value_display[!, :FinalPoints] = Int.(round.(top_value_display.FinalPoints))
top_value_display[!, :Value] = Int.(round.(top_value_display.FinalPoints ./ top_value_display.Cost))
markdown_table(top_value_display)
```

## 2025 vs historical performance

Some riders overperformed compared to their historical averages, while others underperformed. This section compares the 2025 Tour de France performance against riders' VeloGames performances in 2024 and 2023.

```{julia}
#| echo: false
#| cache: true

println("ðŸ“Š Collecting historical Tour de France data for comparison...")

# Historical Tour de France data sources (from stage race predictor)
tdf_2024_url = "https://www.velogames.com/velogame/2024/riders.php"
tdf_2023_url = "https://www.velogames.com/velogame/2023/riders.php"

# Get historical data
println("ðŸ“¥ Fetching 2024 Tour de France results...")
try
    global tdf_2024_historical = getvgriders(tdf_2024_url; cache_config=tdf_final_cache)
    tdf_2024_historical = select(tdf_2024_historical, :riderkey, :rider, :points => :points_2024)
    println("   âœ… 2024 Tour data: $(nrow(tdf_2024_historical)) riders")
    global has_2024_historical = true
catch e
    println("   âš ï¸ 2024 Tour data unavailable: $e")
    global tdf_2024_historical = DataFrame(riderkey=String[], rider=String[], points_2024=Float64[])
    global has_2024_historical = false
end

println("ðŸ“¥ Fetching 2023 Tour de France results...")
try
    global tdf_2023_historical = getvgriders(tdf_2023_url; cache_config=tdf_final_cache)
    tdf_2023_historical = select(tdf_2023_historical, :riderkey, :rider, :points => :points_2023)
    println("   âœ… 2023 Tour data: $(nrow(tdf_2023_historical)) riders")
    global has_2023_historical = true
catch e
    println("   âš ï¸ 2023 Tour data unavailable: $e")
    global tdf_2023_historical = DataFrame(riderkey=String[], rider=String[], points_2023=Float64[])
    global has_2023_historical = false
end

# Merge historical data with 2025 results
historical_comparison = allriderdata[:, [:riderkey, :rider, :team, :class, :cost, :points]]
rename!(historical_comparison, :points => :points_2025)

if has_2024_historical
    historical_comparison = leftjoin(historical_comparison, tdf_2024_historical, on=:riderkey, makeunique=true)
    println("   âœ… Added 2024 data to comparison")
else
    historical_comparison[!, :points_2024] = zeros(Float64, nrow(historical_comparison))
    println("   âš ï¸ Using zeros for 2024 data")
end

if has_2023_historical
    historical_comparison = leftjoin(historical_comparison, tdf_2023_historical, on=:riderkey, makeunique=true)
    println("   âœ… Added 2023 data to comparison")
else
    historical_comparison[!, :points_2023] = zeros(Float64, nrow(historical_comparison))
    println("   âš ï¸ Using zeros for 2023 data")
end

# Handle missing values
for col in [:points_2024, :points_2023]
    if hasproperty(historical_comparison, col)
        historical_comparison[ismissing.(historical_comparison[!, col]), col] .= 0.0
        historical_comparison[!, col] = Float64.(historical_comparison[!, col])
    else
        historical_comparison[!, col] = zeros(Float64, nrow(historical_comparison))
    end
end

# Calculate historical averages and performance changes
historical_comparison[!, :historical_avg] = (historical_comparison.points_2024 .+ historical_comparison.points_2023) ./ 2
historical_comparison[!, :performance_change] = historical_comparison.points_2025 .- historical_comparison.historical_avg
historical_comparison[!, :performance_ratio] = historical_comparison.points_2025 ./ (historical_comparison.historical_avg .+ 1e-6)  # Avoid division by zero

# Filter to riders with meaningful historical data (participated in at least one previous Tour)
meaningful_riders = filter(row -> (row.points_2024 + row.points_2023) > 0, historical_comparison)

println("ðŸ“ˆ Historical comparison complete: $(nrow(meaningful_riders)) riders with historical Tour data")
```

### Performance vs Historical Average: Above-Average Riders

These riders significantly exceeded their 2023-2024 Tour de France averages in 2025:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Top overperformers (minimum 100 point improvement to filter noise)
    overperformers = filter(row -> row.performance_change >= 100, meaningful_riders)
    top_overperformers = sort(overperformers, :performance_change, rev=true)[1:min(15, nrow(overperformers)), :]

    if nrow(top_overperformers) > 0
        overperform_display = select(top_overperformers,
            :rider => :Rider,
            :team => :Team,
            :class => :Class,
            :cost => :Cost,
            :points_2025 => :Points2025,
            :historical_avg => :HistoricalAvg,
            :performance_change => :Improvement
        )
        overperform_display[!, :Points2025] = Int.(round.(overperform_display.Points2025))
        overperform_display[!, :HistoricalAvg] = Int.(round.(overperform_display.HistoricalAvg))
        overperform_display[!, :Improvement] = Int.(round.(overperform_display.Improvement))

        markdown_table(overperform_display)
    else
        println("No riders with significant overperformance (â‰¥100 points) found.")
    end
else
    println("No riders with historical data available for comparison.")
end
```

### Performance vs Historical Average: Below-Average Riders

These riders fell well short of their 2023-2024 Tour de France averages:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Top underperformers (minimum -100 point decline to filter noise)
    underperformers = filter(row -> row.performance_change <= -100, meaningful_riders)
    top_underperformers = sort(underperformers, :performance_change)[1:min(15, nrow(underperformers)), :]

    if nrow(top_underperformers) > 0
        underperform_display = select(top_underperformers,
            :rider => :Rider,
            :team => :Team,
            :class => :Class,
            :cost => :Cost,
            :points_2025 => :Points2025,
            :historical_avg => :HistoricalAvg,
            :performance_change => :Decline
        )
        underperform_display[!, :Points2025] = Int.(round.(underperform_display.Points2025))
        underperform_display[!, :HistoricalAvg] = Int.(round.(underperform_display.HistoricalAvg))
        underperform_display[!, :Decline] = Int.(round.(underperform_display.Decline))

        markdown_table(underperform_display)
    else
        println("No riders with significant underperformance (â‰¤-100 points) found.")
    end
else
    println("No riders with historical data available for comparison.")
end
```

### Performance Change Distribution

```{julia}
#| echo: false
#| fig-cap: "Distribution of 2025 performance changes compared to 2023-2024 historical averages"

if nrow(meaningful_riders) > 0
    # Create histogram of performance changes
    histogram(meaningful_riders.performance_change,
        bins=30,
        xlabel="Performance Change vs Historical Average (Points)",
        ylabel="Number of Riders",
        title="2025 Tour Performance vs 2023-2024 Average",
        legend=false,
        alpha=0.7,
        size=(800, 500),
        dpi=300
    )

    # Add vertical line at zero
    vline!([0], color=:red, linestyle=:dash, linewidth=2, label="No Change")
else
    println("No historical data available for performance change analysis.")
end
```

### Year-over-Year Performance Matrix

This table shows the three-year performance pattern for riders who participated in all three Tours:

```{julia}
#| echo: false

if nrow(meaningful_riders) > 0
    # Filter to riders who participated in all three years (non-zero points)
    three_year_riders = filter(row -> row.points_2023 > 0 && row.points_2024 > 0 && row.points_2025 > 0, meaningful_riders)

    if nrow(three_year_riders) > 0
        # Sort by 2025 performance and show top performers
        three_year_top = sort(three_year_riders, :points_2025, rev=true)[1:min(20, nrow(three_year_riders)), :]

        three_year_display = select(three_year_top,
            :rider => :Rider,
            :team => :Team,
            :class => :Class,
            :cost => :Cost,
            :points_2023 => :Tour2023,
            :points_2024 => :Tour2024,
            :points_2025 => :Tour2025
        )

        # Round all point columns
        for col in [:Tour2023, :Tour2024, :Tour2025]
            three_year_display[!, col] = Int.(round.(three_year_display[!, col]))
        end

        # Calculate trend indicators
        three_year_display[!, :Trend] = ["ðŸ“ˆ" for _ in 1:nrow(three_year_display)]  # Default upward
        for i in 1:nrow(three_year_display)
            if three_year_display[i, :Tour2025] < three_year_display[i, :Tour2024] < three_year_display[i, :Tour2023]
                three_year_display[i, :Trend] = "ðŸ“‰"  # Declining
            elseif three_year_display[i, :Tour2025] > three_year_display[i, :Tour2024] > three_year_display[i, :Tour2023]
                three_year_display[i, :Trend] = "ðŸ“ˆ"  # Improving
            else
                three_year_display[i, :Trend] = "ðŸ“Š"  # Mixed
            end
        end

        markdown_table(three_year_display)

        println("\nðŸ“ˆ = Improving trend, ðŸ“‰ = Declining trend, ðŸ“Š = Mixed performance")
    else
        println("No riders found who participated in all three Tours (2023, 2024, 2025).")
    end
else
    println("Insufficient historical data for three-year comparison.")
end
```

