---
title: "Stage race team builder"
subtitle: "Monte Carlo simulation-based fantasy cycling team optimiser"
format: html
---

# Configuration

Set up the race details and optimisation parameters:

```{julia}
using Velogames, DataFrames, Statistics, MarkdownTables

# Race configuration
race_name = "tdf"  # Short name from get_url_pattern (e.g. "tdf", "vuelta", "giro")
race_year = 2025
racehash = ""  # VG startlist hash filter (leave empty for all riders)

# Optional: betting odds URL (leave empty to skip)
odds_url = ""

# Simulation parameters
n_sims = 1000  # Monte Carlo simulations (more = smoother, slower)
history_years = 3  # How many years of race history to use

# Exclusions (add rider names to avoid)
excluded_riders = String[]

# Cache configuration
race_cache = CacheConfig(joinpath(homedir(), ".velogames_cache"), 6, true)
```

# Race setup

```{julia}
#| echo: false
# Set up race configuration from the short name
config = setup_race(race_name, race_year; cache_config=race_cache)

print_race_info(config)
println("Simulations: $n_sims")
println("History years: $history_years")
```

# Team optimisation

```{julia}
#| echo: false
println("BUILDING OPTIMAL TEAM")
println("="^40)

# Run the full prediction pipeline
predicted, chosenteam = solve_stage(config;
    racehash=racehash,
    history_years=history_years,
    odds_url=odds_url,
    n_sims=n_sims,
    excluded_riders=excluded_riders)

println()
println("Pipeline complete: $(nrow(predicted)) riders analysed")
```

# Your optimal team

```{julia}
#| echo: false
if @isdefined(chosenteam) && nrow(chosenteam) > 0
    cost_col = :vgcost in propertynames(chosenteam) ? :vgcost : :cost
    total_cost = sum(chosenteam[!, cost_col])
    total_evg = sum(chosenteam.expected_vg_points)

    println("YOUR OPTIMAL TEAM")
    println("="^40)
    println("Total Cost: $total_cost / 100 credits")
    println("Expected VG Points: $(round(total_evg, digits=1))")
    println("Budget Remaining: $(100 - total_cost) credits")
    println("Team Size: $(nrow(chosenteam)) riders")
    println()

    # Display team with key columns
    display_cols = [:rider, :team, :classraw, cost_col, :expected_vg_points, :strength, :uncertainty]
    for col in [:expected_finish_pts, :expected_assist_pts]
        if col in propertynames(chosenteam)
            push!(display_cols, col)
        end
    end

    team_display = chosenteam[:, display_cols]

    # Round numeric columns for display
    for col in names(team_display)
        if eltype(team_display[!, col]) <: Union{Missing,Number}
            team_display[!, col] = round.(team_display[!, col], digits=1)
        end
    end

    # Clean team names
    if hasproperty(team_display, :team)
        team_display = transform(team_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
    end

    display(markdown_table(sort(team_display, :expected_vg_points, rev=true)))

    # Classification summary
    if hasproperty(chosenteam, :classraw)
        println("\nClassification breakdown:")
        for class in sort(unique(chosenteam.classraw))
            n = count(chosenteam.classraw .== class)
            println("  $class: $n")
        end
    end
else
    println("No optimal team generated - check configuration and try again")
end
```

# Full prediction rankings

Top 30 riders by expected VG points:

```{julia}
#| echo: false
if @isdefined(predicted) && nrow(predicted) > 0
    cost_col = :vgcost in propertynames(predicted) ? :vgcost : :cost

    # Show top 30 riders
    ranking_cols = [:rider, :team, :classraw, cost_col, :expected_vg_points, :strength, :uncertainty]
    for col in [:expected_finish_pts, :expected_assist_pts]
        if col in propertynames(predicted)
            push!(ranking_cols, col)
        end
    end

    if :chosen in propertynames(predicted)
        push!(ranking_cols, :chosen)
    end

    ranking = sort(predicted[:, ranking_cols], :expected_vg_points, rev=true)
    top_n = min(30, nrow(ranking))
    ranking_display = ranking[1:top_n, :]

    # Round for display
    for col in names(ranking_display)
        if eltype(ranking_display[!, col]) <: Union{Missing,Number}
            ranking_display[!, col] = round.(ranking_display[!, col], digits=1)
        end
    end

    if hasproperty(ranking_display, :team)
        ranking_display = transform(ranking_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
    end

    display(markdown_table(ranking_display))
end
```

# Alternative picks

```{julia}
#| echo: false
if @isdefined(predicted) && @isdefined(chosenteam) && nrow(chosenteam) > 0
    cost_col = :vgcost in propertynames(predicted) ? :vgcost : :cost

    println("ALTERNATIVE CONSIDERATIONS")
    println("="^45)

    # Get riders not in optimal team
    not_chosen = filter(:chosen => ==(false), predicted)

    if nrow(not_chosen) > 0
        not_chosen[!, :value] = not_chosen.expected_vg_points ./ not_chosen[!, cost_col]

        # Top 10 value picks not selected
        println("\nTop Value Riders Not Selected:")
        top_value = sort(not_chosen, :value, rev=true)[1:min(10, nrow(not_chosen)), :]
        value_display = top_value[:, [:rider, :team, :classraw, cost_col, :expected_vg_points, :value]]
        for col in names(value_display)
            if eltype(value_display[!, col]) <: Union{Missing,Number}
                value_display[!, col] = round.(value_display[!, col], digits=1)
            end
        end
        if hasproperty(value_display, :team)
            value_display = transform(value_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
        end
        display(markdown_table(value_display))

        # High-upside picks (high strength, high uncertainty)
        println("\nHigh Upside Picks (strong but uncertain):")
        not_chosen[!, :upside] = not_chosen.strength .+ not_chosen.uncertainty
        upside = sort(not_chosen, :upside, rev=true)[1:min(5, nrow(not_chosen)), :]
        upside_display = upside[:, [:rider, :team, :classraw, cost_col, :expected_vg_points, :strength, :uncertainty]]
        for col in names(upside_display)
            if eltype(upside_display[!, col]) <: Union{Missing,Number}
                upside_display[!, col] = round.(upside_display[!, col], digits=1)
            end
        end
        if hasproperty(upside_display, :team)
            upside_display = transform(upside_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
        end
        display(markdown_table(upside_display))

        # Budget options
        println("\nBudget Options (cost <= 6):")
        cheap_options = filter(row -> row[cost_col] <= 6, not_chosen)
        if nrow(cheap_options) > 0
            cheap_sorted = sort(cheap_options, :expected_vg_points, rev=true)[1:min(5, nrow(cheap_options)), :]
            cheap_display = cheap_sorted[:, [:rider, :team, :classraw, cost_col, :expected_vg_points]]
            for col in names(cheap_display)
                if eltype(cheap_display[!, col]) <: Union{Missing,Number}
                    cheap_display[!, col] = round.(cheap_display[!, col], digits=1)
                end
            end
            if hasproperty(cheap_display, :team)
                cheap_display = transform(cheap_display, :team => ByRow(x -> replace(x, "|" => "-")) => :team)
            end
            display(markdown_table(cheap_display))
        else
            println("No riders at cost <= 6 available")
        end
    else
        println("All available riders were selected!")
    end
end
```

# How to use this tool

**Quick start:**

1. Update `race_name` to the short name of the race (e.g. `"tdf"`, `"vuelta"`, `"giro"`)
2. Update `race_year` to the current year
3. Optionally set `racehash` if the VG site uses startlist filtering
4. Run all cells to get your optimal team
5. Copy the team into VeloGames

**Prediction pipeline:**
The optimiser uses Monte Carlo simulation to estimate **expected Velogames points** for each rider:

1. Fetches VG rider costs, season points, and classifications
2. Fetches PCS specialty ratings (GC, TT, sprint, climber, one-day)
3. Blends PCS specialties according to rider classification (e.g. all-rounders weight GC + TT + climbing)
4. Fetches PCS race-specific history (past editions of this grand tour)
5. Optionally fetches betting odds
6. Estimates rider strength via Bayesian updating of all signals
7. Runs Monte Carlo simulation to get finishing position probabilities
8. Computes expected VG points using aggregate stage race scoring
9. Optimises team selection with classification constraints (2 all-rounders, 2 climbers, 1 sprinter, 3+ unclassed)

**Note:** This uses an aggregate simulation approach (overall finishing positions rather than stage-by-stage). Stage-by-stage simulation with course profile matching is planned for a future release.
